/**
 * This library helps to handle "String Substitutions" that are used in a lot of libraries and even in the
 * native `console.log` functionality.
 *
 * @packageDocumentation
 */

/**
 * Responsible for fmts creation, concatenation and assembling.
 */
export declare class Fmt {
    /**
     * Concatenates two or more fmts with each other with preserving of the formatting shape.
     *
     * @remarks
     * By the way, you can always concatenate multiple fmts with this construction:
     *
     * ```ts
     * fmt`${fmt`1`}${fmt`2`}`
     * ```
     *
     * But it may produce a lot of nested fmts inside of each other and it will damage performance:
     *
     * ```ts
     * const aLotOfFmts = Array.from({ length: 1000 }, () => fmt`some fmt`)
     *
     * // non-performant way
     * aLotOfFmts.reduce((a, b) => fmt`${a} ${b}`)
     *
     * // performant way
     * Fmt.concat(...aLotOfFmts)
     * ```
     *
     * @example
     * ```ts
     * const numbers = [0, 1, 2]
     * const numbersAsFmts = numbers.map((x) => fmt`${fmt.sub(x, '%d')}`)
     *
     * // way 1 - `Fmt.concat()`
     * const singleFmt1 = Fmt.concat(...numbersAsFmts)
     *
     * // way 2 - instance's `.concat()`
     * // also joining them with ', '
     * const singleFmt2 = numbersAsFmts.reduce((a, b) => a.concat(fmt`, `, b))
     * ```
     */
    static concat(...fmts: Fmt[]): Fmt;
    private template;
    private expressions;
    constructor(template: string[], expressions: unknown[]);
    /**
     * Shortcut for fmts chaining
     *
     * @see {@link Fmt.concat}
     */
    concat(...others: Fmt[]): Fmt;
    /**
     * Final chord of `fmt`. Assembles passed template string into a printf-style array of arguments
     * that you can pass to printing function then.
     *
     * @example
     *
     * ```ts
     * console.log(fmt`Hey, ${fmt.sub('Aubrey', '%o')}!`.assemble())
     * // ['Hey, %o!', 'Aubrey']
     *
     * // spread to let `console.log` format your `fmt`!
     * console.log(...fmt`Hey, ${fmt.sub('Aubrey', '%o')}!`.assemble())
     * // Hey, 'Aubrey'!
     * ```
     */
    assemble(): [string, ...unknown[]];
}

/**
 * Tag function for template literals which wraps its contents into a {@link Fmt} instance.
 *
 * @remarks
 * Use {@link sub} for values substitution
 *
 * @example
 * ```ts
 * // Simple usage
 * console.log(...fmt`Hey, ${fmt.sub('Buddy', '%s')}!`.assemble())
 *
 * // Nesting fmts to each other
 * const part1 = fmt`Foo: ${fmt.sub({ foo: true }, '%o')}`
 * const part2 = fmt`Bar: ${fmt.sub({ bar: false }, '%o')}`
 * console.log(...fmt`Part 2: ${part2}\nPart 1: ${part1}`.assemble())
 * ```
 */
export declare const fmt: FmtFn;

export declare interface FmtFn {
    /**
     * {@link Fmt} factory via "Template literals"
     *
     * @example
     * ```
     * fmt`I will be converted to an "Fmt" instance`
     * ```
     */
    (template: TemplateStringsArray, ...expressions: unknown[]): Fmt;
    /**
     * It is used for actual substitutions
     */
    sub: typeof sub;
}

/**
 * Constructs substitution
 *
 * @example
 * ```ts
 * import { sub, fmt } from 'fmt-subs'
 *
 * const fmtInstance = fmt`Hello, ${sub({ value: 'World' }, '%o')}!`
 *
 * // deep equality
 * fmtInstance.assemble() == ['Hello, %o!', { value: 'World' }]
 * ```
 *
 * @param something - what to substitute
 * @param substitution - an actual string substitution
 * @returns token that could be used inside of `fmt` template literal
 */
export declare function sub(something: unknown, substitution: string): SubstitutionToken;

/**
 * Token that are recognized by `fmt` internally during assembling
 */
export declare class SubstitutionToken {
    /**
     * What will be replaced by substitution
     */
    readonly something: unknown;
    /**
     * Substitution. Will be inserted instead of `something`
     */
    readonly sub: string;
    constructor(something: unknown, sub: string);
}

export { }
