// dist-tsc/fmt.js
var SubstitutionToken = class {
  something;
  sub;
  constructor(something, sub2) {
    this.something = something;
    this.sub = sub2;
  }
};
var Fmt = class {
  static concat(...fmts) {
    const sharedTemplate = [];
    const sharedExpressions = [];
    let lastTail = null;
    for (const { template, expressions } of fmts) {
      const len = template.length;
      const tail = template[len - 1];
      if (lastTail) {
        if (len === 1) {
          lastTail += tail;
        } else {
          const [head] = template;
          sharedTemplate.push(lastTail + head);
          lastTail = tail;
          if (len > 2) {
            sharedTemplate.push(...template.slice(1, -1));
          }
        }
      } else {
        lastTail = tail;
        if (len > 1) {
          sharedTemplate.push(...template.slice(0, -1));
        }
      }
      sharedExpressions.push(...expressions);
    }
    if (lastTail !== null) {
      sharedTemplate.push(lastTail);
    }
    return new Fmt(sharedTemplate, sharedExpressions);
  }
  template;
  expressions;
  constructor(template, expressions) {
    this.template = template;
    this.expressions = expressions;
  }
  concat(...others) {
    return Fmt.concat(this, ...others);
  }
  assemble() {
    const finalStrArray = [];
    const substitutions = [];
    for (let i = 0, len = this.expressions.length; i < len; i++) {
      finalStrArray.push(this.template[i]);
      const expr = this.expressions[i];
      if (isSubToken(expr)) {
        substitutions.push(expr.something);
        finalStrArray.push(expr.sub);
      } else if (isFmt(expr)) {
        const [compiledTemplate, ...extractedSubs] = expr.assemble();
        finalStrArray.push(compiledTemplate);
        substitutions.push(...extractedSubs);
      } else {
        finalStrArray.push(String(expr));
      }
    }
    finalStrArray.push(this.template[this.template.length - 1]);
    return [finalStrArray.join(""), ...substitutions];
  }
};
function sub(something, substitution) {
  return new SubstitutionToken(something, substitution);
}
function isFmt(x) {
  return x instanceof Fmt;
}
function isSubToken(x) {
  return x instanceof SubstitutionToken;
}
var fmt = (template, ...expressions) => {
  return new Fmt([...template], expressions);
};
fmt.sub = sub;
export {
  Fmt,
  SubstitutionToken,
  fmt,
  sub
};
