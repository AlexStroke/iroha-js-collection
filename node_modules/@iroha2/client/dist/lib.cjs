'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var dataModel = require('@iroha2/data-model');
var Emittery = require('emittery');
var JsonBigIntParseFactory = require('json-bigint/lib/parse.js');
var Debug = require('debug');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var Emittery__default = /*#__PURE__*/_interopDefaultLegacy(Emittery);
var JsonBigIntParseFactory__default = /*#__PURE__*/_interopDefaultLegacy(JsonBigIntParseFactory);
var Debug__default = /*#__PURE__*/_interopDefaultLegacy(Debug);

let currentScope = null;
function createScope() {
    const state = {
        garbage: [],
    };
    return {
        run(cb) {
            if (currentScope)
                throw new Error('Already in the scope');
            try {
                currentScope = state;
                cb();
            }
            finally {
                currentScope = null;
            }
        },
        free() {
            for (const x of state.garbage) {
                x.free();
            }
            state.garbage = [];
        },
    };
}
function collect(some) {
    if (!currentScope)
        throw new Error('Used out of a scope');
    currentScope.garbage.push(some);
    return some;
}

const MAX_SAFE_U32 = 0xffff_ffff;
function randomU32() {
    return ~~(Math.random() * MAX_SAFE_U32);
}
function transformProtocolInUrlFromHttpToWs(url) {
    return url.replace(/^https?:\/\//, (substr) => {
        const isSafe = /https/.test(substr);
        return `ws${isSafe ? 's' : ''}://`;
    });
}
function setupWebSocket(params) {
    const debug = params.parentDebugger.extend('websocket');
    const url = transformProtocolInUrlFromHttpToWs(params.baseURL) + params.endpoint;
    const ee = new Emittery__default["default"]();
    debug('opening connection to %o', url);
    const { isClosed, send, close } = params.adapter.initWebSocket({
        url,
        onopen: (e) => {
            debug('connection opened');
            ee.emit('open', e);
        },
        onclose: (e) => {
            debug('connection closed; code: %o, reason: %o, was clean: %o', e.code, e.reason, e.wasClean);
            ee.emit('close', e);
        },
        onerror: (e) => {
            debug('connection error %o', e);
            ee.emit('error', e);
        },
        onmessage: ({ data }) => {
            debug('message', data);
            ee.emit('message', data);
        },
    });
    async function closeAsync() {
        if (isClosed())
            return;
        debug('closing connection...');
        close();
        return ee.once('close').then(() => { });
    }
    async function accepted() {
        return new Promise((resolve, reject) => {
            ee.once('accepted').then(resolve);
            ee.once('close').then(() => {
                reject(new Error('Handshake acquiring failed - connection closed'));
            });
        });
    }
    return { isClosed, send, close: closeAsync, ee, accepted };
}
const jsonBigIntParse = JsonBigIntParseFactory__default["default"]({ useNativeBigInt: true });
function parseJsonWithBigInts(raw) {
    return jsonBigIntParse(raw);
}

let __crypto = null;
function setCrypto(crypto) {
    __crypto = crypto;
}
function getCrypto() {
    return __crypto;
}

const ENDPOINT_HEALTH = '/health';
const ENDPOINT_TRANSACTION = '/transaction';
const ENDPOINT_QUERY = '/query';
const ENDPOINT_CONFIGURATION = '/configuration';
const ENDPOINT_EVENTS = '/events';
const ENDPOINT_BLOCKS_STREAM = '/block/stream';
const ENDPOINT_STATUS = '/status';
const ENDPOINT_METRICS = '/metrics';
const HEALTHY_RESPONSE = `"Healthy"`;

const debug$1 = Debug__default["default"]('@iroha2/client:events');
/**
 * Promise resolved when connection handshake is acquired
 */
async function setupEvents(params) {
    const { ee, isClosed, close, accepted, send: sendRaw, } = setupWebSocket({
        baseURL: params.toriiApiURL,
        endpoint: ENDPOINT_EVENTS,
        parentDebugger: debug$1,
        adapter: params.adapter,
    });
    function send(msg) {
        sendRaw(dataModel.VersionedEventSubscriberMessage.toBuffer(dataModel.VersionedEventSubscriberMessage('V1', msg)));
    }
    ee.on('open', () => {
        send(dataModel.EventSubscriberMessage('SubscriptionRequest', params.filter));
    });
    ee.on('message', (raw) => {
        const event = dataModel.VersionedEventPublisherMessage.fromBuffer(raw).as('V1');
        if (event.is('SubscriptionAccepted')) {
            debug$1('subscription accepted');
            ee.emit('accepted');
        }
        else {
            ee.emit('event', event.as('Event'));
            send(dataModel.EventSubscriberMessage('EventReceived'));
        }
    });
    await accepted();
    return {
        stop: close,
        ee: 
        // Emittery typing bug :<
        ee,
        isClosed,
    };
}

const debug = Debug__default["default"]('@iroha2/client:blocks-stream');
async function setupBlocksStream(params) {
    const { ee, send: sendRaw, isClosed, close, accepted, } = setupWebSocket({
        baseURL: params.toriiApiURL,
        endpoint: ENDPOINT_BLOCKS_STREAM,
        parentDebugger: debug,
        adapter: params.adapter,
    });
    function send(msg) {
        sendRaw(dataModel.VersionedBlockSubscriberMessage.toBuffer(dataModel.VersionedBlockSubscriberMessage('V1', msg)));
    }
    ee.on('open', () => {
        send(dataModel.BlockSubscriberMessage('SubscriptionRequest', params.height));
    });
    ee.on('message', (raw) => {
        const msg = dataModel.VersionedBlockPublisherMessage.fromBuffer(raw).as('V1');
        msg.match({
            SubscriptionAccepted() {
                debug('subscription accepted');
                ee.emit('accepted');
            },
            Block(block) {
                debug('new block: %o', block);
                ee.emit('block', block);
                send(dataModel.BlockSubscriberMessage('BlockReceived'));
            },
        });
    });
    await accepted();
    return {
        ee: 
        // Emittery typing bug
        ee,
        stop: close,
        isClosed,
    };
}

function useCryptoAssertive() {
    const crypto = getCrypto();
    if (!crypto) {
        throw new Error('"crypto" is not defined, but required for Iroha Client to function. Have you set it with `setCrypto()`?');
    }
    return crypto;
}
class ClientIncompleteConfigError extends Error {
    static missing(what) {
        return new ClientIncompleteConfigError(`You are trying to use Iroha Client with an incomplete configuration. Missing: ${what}`);
    }
    static fetchIsNotProvided() {
        return new ClientIncompleteConfigError('Incomplete configuration: "fetch" is not defined. It is required for Iroha Client to function. ' +
            "If you are trying to use Client in the environment where Fetch API isn't available, " +
            'be sure to provide its implementation via `fetch` config field.');
    }
    static cryptoIsNotSet() {
        return new ClientIncompleteConfigError('Incomplete configuration: "crypto" is not defined. It is required for Iroha Client to function. Use `setCrypto()` to configure "crypto".');
    }
    constructor(message) {
        super(message);
    }
}
class ResponseError extends Error {
    static throwIfStatusIsNot(response, status) {
        if (response.status !== status)
            throw new ResponseError(response);
    }
    constructor(response) {
        super(`${response.status}: ${response.statusText}`);
    }
}
function makeSignature(keyPair, payload) {
    const { createSignature } = useCryptoAssertive();
    const signature = collect(createSignature(keyPair, payload));
    // Should it be collected?
    const pubKey = keyPair.publicKey();
    return dataModel.Signature({
        public_key: dataModel.PublicKey({
            digest_function: pubKey.digestFunction(),
            payload: pubKey.payload(),
        }),
        payload: signature.signatureBytes(),
    });
}
/**
 *
 * @remarks
 *
 * TODO: `submitBlocking` method, i.e. `submit` + listening for submit
 */
class Client {
    toriiApiURL;
    toriiTelemetryURL;
    keyPair;
    accountId;
    transactionDefaultTTL;
    transactionAddNonce;
    fetch;
    ws;
    constructor(config) {
        this.toriiApiURL = config.torii.apiURL ?? null;
        this.toriiTelemetryURL = config.torii.telemetryURL ?? null;
        this.transactionAddNonce = config.transaction?.addNonce ?? false;
        this.transactionDefaultTTL = config.transaction?.timeToLiveMs ?? 100000n;
        this.keyPair = config.keyPair ?? null;
        this.accountId = config.accountId ?? null;
        if (config.fetch) {
            this.fetch = config.fetch;
        }
        else if (typeof fetch !== 'undefined') {
            this.fetch = fetch;
        }
        this.ws = config.ws ?? null;
    }
    // TODO nice to have
    // public signQuery(payload: QueryPayload): SignedQueryRequest {}
    // public signTransaction(tx: Transaction): Transaction {}
    async getHealth() {
        const url = this.forceGetApiURL();
        try {
            const response = await this.forceGetFetch()(url + ENDPOINT_HEALTH);
            ResponseError.throwIfStatusIsNot(response, 200);
            const text = await response.text();
            if (text !== HEALTHY_RESPONSE) {
                return dataModel.Enum.variant('Err', `Expected '${HEALTHY_RESPONSE}' response; got: '${text}'`);
            }
            return dataModel.Enum.variant('Ok', null);
        }
        catch (err) {
            return dataModel.Enum.variant('Err', `Some error occured: ${String(err)}`);
        }
    }
    async submit(executable, params) {
        const scope = createScope();
        const { createHash } = useCryptoAssertive();
        const accountId = this.forceGetAccountId();
        const keyPair = this.forceGetKeyPair();
        const url = this.forceGetApiURL();
        const payload = dataModel.TransactionPayload({
            instructions: executable,
            time_to_live_ms: this.transactionDefaultTTL,
            nonce: params?.nonce
                ? dataModel.OptionU32('Some', params.nonce)
                : this.transactionAddNonce
                    ? dataModel.OptionU32('Some', randomU32())
                    : dataModel.OptionU32('None'),
            metadata: params?.metadata ?? dataModel.MapNameValue(new Map()),
            creation_time: BigInt(Date.now()),
            account_id: accountId,
        });
        try {
            let finalBytes;
            scope.run(() => {
                const payloadHash = collect(createHash(dataModel.TransactionPayload.toBuffer(payload)));
                const signature = makeSignature(keyPair, payloadHash.bytes());
                finalBytes = dataModel.VersionedTransaction.toBuffer(dataModel.VersionedTransaction('V1', dataModel.Transaction({ payload, signatures: dataModel.VecSignatureOfTransactionPayload([signature]) })));
            });
            const response = await this.forceGetFetch()(url + ENDPOINT_TRANSACTION, {
                body: finalBytes,
                method: 'POST',
            });
            ResponseError.throwIfStatusIsNot(response, 200);
        }
        finally {
            scope.free();
        }
    }
    /**
     * TODO support pagination
     */
    async request(query, params) {
        const scope = createScope();
        const { createHash } = useCryptoAssertive();
        const url = this.forceGetApiURL();
        const accountId = this.forceGetAccountId();
        const keyPair = this.forceGetKeyPair();
        const payload = dataModel.QueryPayload({
            query,
            account_id: accountId,
            timestamp_ms: BigInt(Date.now()),
            filter: params?.filter ?? dataModel.PredicateBox('Raw', dataModel.Predicate('Pass')),
        });
        try {
            let queryBytes;
            scope.run(() => {
                const payloadHash = collect(createHash(dataModel.QueryPayload.toBuffer(payload)));
                const signature = makeSignature(keyPair, payloadHash.bytes());
                queryBytes = dataModel.VersionedSignedQueryRequest.toBuffer(dataModel.VersionedSignedQueryRequest('V1', dataModel.SignedQueryRequest({ payload, signature })));
            });
            const response = await this.forceGetFetch()(url + ENDPOINT_QUERY, {
                method: 'POST',
                body: queryBytes,
            }).then();
            const bytes = new Uint8Array(await response.arrayBuffer());
            if (response.status === 200) {
                // OK
                const value = dataModel.VersionedPaginatedQueryResult.fromBuffer(bytes).as('V1');
                return dataModel.Enum.variant('Ok', value);
            }
            else {
                // ERROR
                const error = dataModel.QueryError.fromBuffer(bytes);
                return dataModel.Enum.variant('Err', error);
            }
        }
        finally {
            scope.free();
        }
    }
    async listenForEvents(params) {
        return setupEvents({
            filter: params.filter,
            toriiApiURL: this.forceGetApiURL(),
            adapter: this.forceGetWs(),
        });
    }
    async listenForBlocksStream(params) {
        return setupBlocksStream({
            height: params.height,
            toriiApiURL: this.forceGetApiURL(),
            adapter: this.forceGetWs(),
        });
    }
    // TODO Iroha WIP
    // public async getPeerConfig() {
    //     await fetch(this.forceGetToriiApiURL() + '/configuration');
    // }
    async setPeerConfig(params) {
        const response = await this.forceGetFetch()(this.forceGetApiURL() + ENDPOINT_CONFIGURATION, {
            method: 'POST',
            body: JSON.stringify(params),
            headers: {
                'Content-Type': 'application/json',
            },
        });
        ResponseError.throwIfStatusIsNot(response, 200);
    }
    async getStatus() {
        const response = await this.forceGetFetch()(this.forceGetTelemetryURL() + ENDPOINT_STATUS);
        ResponseError.throwIfStatusIsNot(response, 200);
        return response.text().then(parseJsonWithBigInts);
    }
    async getMetrics() {
        return this.forceGetFetch()(this.forceGetTelemetryURL() + ENDPOINT_METRICS).then((response) => {
            ResponseError.throwIfStatusIsNot(response, 200);
            return response.text();
        });
    }
    forceGetApiURL() {
        if (!this.toriiApiURL)
            throw ClientIncompleteConfigError.missing('Torii API URL');
        return this.toriiApiURL;
    }
    forceGetTelemetryURL() {
        if (!this.toriiTelemetryURL)
            throw ClientIncompleteConfigError.missing('Torii Telemetry URL');
        return this.toriiTelemetryURL;
    }
    forceGetAccountId() {
        if (!this.accountId)
            throw ClientIncompleteConfigError.missing('Account ID');
        return this.accountId;
    }
    forceGetKeyPair() {
        if (!this.keyPair)
            throw ClientIncompleteConfigError.missing('Key Pair');
        return this.keyPair;
    }
    forceGetWs() {
        if (!this.ws)
            throw ClientIncompleteConfigError.missing('WebSocket Adapter');
        return this.ws;
    }
    forceGetFetch() {
        if (!this.fetch)
            throw ClientIncompleteConfigError.fetchIsNotProvided();
        return this.fetch;
    }
}

exports.Client = Client;
exports.ClientIncompleteConfigError = ClientIncompleteConfigError;
exports.ResponseError = ResponseError;
exports.getCrypto = getCrypto;
exports.setCrypto = setCrypto;
exports.setupBlocksStream = setupBlocksStream;
exports.setupEvents = setupEvents;
