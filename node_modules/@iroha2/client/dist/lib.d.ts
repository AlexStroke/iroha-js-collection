import { Event as Event$1, FilterBox, VersionedCommittedBlock, MapNameValue, Result, PaginatedQueryResult, QueryError, AccountId, PredicateBox, Executable, QueryBox } from '@iroha2/data-model';
import { KeyPair, IrohaCryptoInterface } from '@iroha2/crypto-core';
import Emittery from 'emittery';

declare type SendData = string | ArrayBuffer;
declare type IncomingData = ArrayBufferView;
interface IsomorphicWebSocket {
    readonly send: (data: SendData) => void;
    readonly close: (code?: number, reason?: string) => void;
    readonly isClosed: () => boolean;
}
interface CloseEvent {
    readonly code: number;
    readonly reason: string;
    readonly wasClean: boolean;
}
interface Event {
    readonly type: string;
}
interface MessageEvent {
    readonly data: IncomingData;
}
interface InitWebSocketParams {
    url: string;
    onopen: (event: Event) => void;
    onclose: (event: CloseEvent) => void;
    onerror: (event: Event) => void;
    onmessage: (event: MessageEvent) => void;
}
interface IsomorphicWebSocketAdapter {
    initWebSocket: (params: InitWebSocketParams) => IsomorphicWebSocket;
}

interface SocketEmitMapBase {
    accepted: undefined;
    open: Event;
    close: CloseEvent;
    error: Event;
    message: ArrayBufferView;
}

interface EventsEmitteryMap extends SocketEmitMapBase {
    event: Event$1;
}
interface SetupEventsParams {
    toriiApiURL: string;
    filter: FilterBox;
    adapter: IsomorphicWebSocketAdapter;
}
interface SetupEventsReturn {
    stop: () => Promise<void>;
    isClosed: () => boolean;
    ee: Emittery<EventsEmitteryMap>;
}
/**
 * Promise resolved when connection handshake is acquired
 */
declare function setupEvents(params: SetupEventsParams): Promise<SetupEventsReturn>;

interface SetupBlocksStreamParams {
    toriiApiURL: string;
    height: bigint;
    adapter: IsomorphicWebSocketAdapter;
}
interface BlocksStreamEmitteryMap extends SocketEmitMapBase {
    block: VersionedCommittedBlock;
}
interface SetupBlocksStreamReturn {
    stop: () => Promise<void>;
    isClosed: () => boolean;
    ee: Emittery<BlocksStreamEmitteryMap>;
}
declare function setupBlocksStream(params: SetupBlocksStreamParams): Promise<SetupBlocksStreamReturn>;

declare class ClientIncompleteConfigError extends Error {
    static missing(what: string): ClientIncompleteConfigError;
    static fetchIsNotProvided(): ClientIncompleteConfigError;
    static cryptoIsNotSet(): ClientIncompleteConfigError;
    private constructor();
}
declare class ResponseError extends Error {
    static throwIfStatusIsNot(response: Response, status: number): void;
    constructor(response: Response);
}
interface SubmitParams {
    nonce?: number;
    metadata?: MapNameValue;
}
declare type HealthResult = Result<null, string>;
declare type RequestResult = Result<PaginatedQueryResult, QueryError>;
declare type ListenEventsParams = Pick<SetupEventsParams, 'filter'>;
declare type ListenBlocksStreamParams = Pick<SetupBlocksStreamParams, 'height'>;
interface PeerStatus {
    peers: bigint | number;
    blocks: bigint | number;
    txs_accepted: bigint | number;
    txs_rejected: bigint | number;
    view_changes: bigint | number;
    uptime: {
        secs: bigint | number;
        nanos: number;
    };
}
interface SetPeerConfigParams {
    LogLevel?: 'WARN' | 'ERROR' | 'INFO' | 'DEBUG' | 'TRACE';
}
interface UserConfig {
    torii: {
        apiURL?: string | null;
        telemetryURL?: string | null;
    };
    keyPair?: KeyPair;
    accountId?: AccountId;
    transaction?: {
        /**
         * @default 100_000n
         */
        timeToLiveMs?: bigint;
        /**
         * @default false
         */
        addNonce?: boolean;
    };
    /**
     * Implementation of the [fetch](https://fetch.spec.whatwg.org/#fetch-method) method.
     * Must be provided in the environment where it is not available by default, i.e.
     * in Node.js older than 17.5.
     *
     * See also:
     *
     * - [undici](https://www.npmjs.com/package/undici)
     * - [node-fetch](https://www.npmjs.com/package/node-fetch)
     */
    fetch?: typeof fetch;
    ws?: IsomorphicWebSocketAdapter;
}
interface RequestParams {
    /**
     * @default PredicateBox('Raw', Predicate('Pass'))
     */
    filter?: PredicateBox;
}
/**
 *
 * @remarks
 *
 * TODO: `submitBlocking` method, i.e. `submit` + listening for submit
 */
declare class Client {
    toriiApiURL: string | null;
    toriiTelemetryURL: string | null;
    keyPair: null | KeyPair;
    accountId: null | AccountId;
    transactionDefaultTTL: bigint;
    transactionAddNonce: boolean;
    fetch: typeof fetch | null;
    ws: IsomorphicWebSocketAdapter | null;
    constructor(config: UserConfig);
    getHealth(): Promise<HealthResult>;
    submit(executable: Executable, params?: SubmitParams): Promise<void>;
    /**
     * TODO support pagination
     */
    request(query: QueryBox, params?: RequestParams): Promise<RequestResult>;
    listenForEvents(params: ListenEventsParams): Promise<SetupEventsReturn>;
    listenForBlocksStream(params: ListenBlocksStreamParams): Promise<SetupBlocksStreamReturn>;
    setPeerConfig(params: SetPeerConfigParams): Promise<void>;
    getStatus(): Promise<PeerStatus>;
    getMetrics(): Promise<string>;
    private forceGetApiURL;
    private forceGetTelemetryURL;
    private forceGetAccountId;
    private forceGetKeyPair;
    private forceGetWs;
    private forceGetFetch;
}

declare function setCrypto(crypto: IrohaCryptoInterface | null): void;
declare function getCrypto(): null | IrohaCryptoInterface;

export { BlocksStreamEmitteryMap, Client, ClientIncompleteConfigError, CloseEvent, Event, EventsEmitteryMap, HealthResult, IncomingData, InitWebSocketParams, IsomorphicWebSocket, IsomorphicWebSocketAdapter, ListenBlocksStreamParams, ListenEventsParams, MessageEvent, PeerStatus, RequestParams, RequestResult, ResponseError, SendData, SetPeerConfigParams, SetupBlocksStreamParams, SetupBlocksStreamReturn, SetupEventsParams, SetupEventsReturn, SubmitParams, UserConfig, getCrypto, setCrypto, setupBlocksStream, setupEvents };
