var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// packages/enum/src/lib.ts
var lib_exports = {};
__export(lib_exports, {
  ENUM_EMPTY_VALUE: () => ENUM_EMPTY_VALUE,
  Enum: () => Enum
});
module.exports = __toCommonJS(lib_exports);
var ENUM_EMPTY_VALUE = Symbol("empty");
var Enum = class {
  static variant(tag, value = ENUM_EMPTY_VALUE) {
    return new Enum(tag, value);
  }
  tag;
  value;
  constructor(tag, value = ENUM_EMPTY_VALUE) {
    this.tag = tag;
    this.value = value;
  }
  get isEmpty() {
    return this.value === ENUM_EMPTY_VALUE;
  }
  is(tag) {
    return this.tag === tag;
  }
  as(tag) {
    if (this.is(tag)) {
      if (this.isEmpty) {
        throw new Error(`Enum cast failed - enum "${tag}" is empty`);
      }
      return this.value;
    }
    throw new Error(`Enum cast failed - enum is "${this.tag}", not "${tag}"`);
  }
  match(matchMap) {
    const fn = matchMap[this.tag];
    return this.isEmpty ? fn() : fn(this.value);
  }
  toJSON() {
    const { tag, value, isEmpty } = this;
    return isEmpty ? { tag } : { tag, value };
  }
};
