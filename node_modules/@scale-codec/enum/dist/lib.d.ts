/**
 * Minimal tool to work with Rust's Enums.
 *
 * @packageDocumentation
 */

/**
 * Typed-wrapper to handle Rust's Enum concept.
 *
 * @remarks
 *
 * `Def` generic type is a **definition of enum variants**. It should be defined like this:
 *
 * ```ts
 * type MyDef = 'EmptyVariant' | ['VarWithBool', boolean]
 *
 * type MyEnum = Enum<MyDef>
 * ```
 *
 * Then you could create enums with that definition type-safely:
 *
 * ```ts
 * const val1: MyEnum = Enum.variant('EmptyVariant')
 * const val2: MyEnum = Enum.variant('VarWithBool', true)
 * ```
 */
export declare class Enum<Def extends EnumGenericDef> {
    static variant<E extends Enum<any>>(...args: EnumDefToFactoryArgs<EnumDef<E>>): E;
    static variant<Def extends EnumGenericDef>(...args: EnumDefToFactoryArgs<Def>): Enum<Def>;
    readonly tag: string;
    /**
     * Inner value is untyped and should be used with caution
     */
    readonly value: typeof ENUM_EMPTY_VALUE | unknown;
    constructor(tag: string, value?: typeof ENUM_EMPTY_VALUE | unknown);
    get isEmpty(): boolean;
    /**
     * Check whether an enum instance has this variant name or not
     */
    is(tag: Tags<Def>): boolean;
    /**
     * Returns enum's content if **it exists** and **provided variant name matches with the enum's one**. If not, it
     * throws.
     *
     * @remarks
     * Use it in pair {@link Enum.is} to avoid runtime errors.
     */
    as<T extends TagsValuable<Def>>(tag: T): TagValue<Def, T>;
    /**
     * Pretty simple alternative for 'pattern matching'
     *
     * @example
     *
     * ```ts
     * const file: Result<string, Error> = Enum.variant('Err', new Error('Oops!'))
     *
     * const fileContents = file.match({
     *     Ok: (txt) => txt,
     *     Err: (err) => {
     *         console.error(err)
     *         throw new Error('Bad file')
     *     }
     * })
     * ```
     */
    match<R = any>(matchMap: EnumMatchMap<Def, R>): R;
    toJSON(): {
        tag: string;
        value?: undefined;
    } | {
        tag: string;
        value: unknown;
    };
}

/**
 * Special unique value to mark enum as empty
 */
export declare const ENUM_EMPTY_VALUE: unique symbol;

export declare type EnumDef<E> = E extends Enum<infer Def> ? Def : never;

export declare type EnumDefToFactoryArgs<Def extends EnumGenericDef> = [TagsEmpty<Def>] | (Def extends [string, any] ? Def : never);

export declare type EnumGenericDef = string | [tag: string, value: any];

export declare type EnumMatchMap<Def extends EnumGenericDef, R = any> = {
    [T in TagsEmpty<Def>]: () => R;
} & {
    [T in TagsValuable<Def>]: (value: TagValue<Def, T>) => R;
};

/**
 * Rust's `Option<T>` analog
 *
 * @example
 *
 * ```ts
 * const maybeString: Option<string> = Enum.variant('None')
 * ```
 */
declare type Option_2<T> = Enum<'None' | ['Some', T]>;
export { Option_2 as Option }

/**
 * Rust's `Result<O, E>` analog
 *
 * @example
 *
 * ```ts
 * const file: Result<string, Error> = Enum.variant('Ok', 'file contents')
 * ```
 */
export declare type Result<Ok, Err> = Enum<['Ok', Ok] | ['Err', Err]>;

export declare type Tags<Def extends EnumGenericDef> = TagsEmpty<Def> | TagsValuable<Def>;

export declare type TagsEmpty<Def extends EnumGenericDef> = Def extends string ? Def : never;

export declare type TagsValuable<Def extends EnumGenericDef> = Def extends [infer T, any] ? T & string : never;

export declare type TagValue<Def extends EnumGenericDef, T extends TagsValuable<Def>> = Def extends [T, infer V] ? V : never;

export { }
