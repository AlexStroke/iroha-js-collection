var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// packages/definition-runtime/src/lib.ts
var lib_exports = {};
__export(lib_exports, {
  Bool: () => Bool,
  Compact: () => Compact,
  DecodeTrace: () => DecodeTrace,
  DecodeTraceCollector: () => DecodeTraceCollector,
  I128: () => I128,
  I16: () => I16,
  I32: () => I32,
  I64: () => I64,
  I8: () => I8,
  Logger: () => Logger,
  Str: () => Str,
  TrackValueInspect: () => TrackValueInspect,
  U128: () => U128,
  U16: () => U16,
  U32: () => U32,
  U64: () => U64,
  U8: () => U8,
  VecU8: () => VecU8,
  Void: () => Void,
  buildDecodeTraceStepsFmt: () => buildDecodeTraceStepsFmt,
  createArrayCodec: () => createArrayCodec,
  createArrayU8Codec: () => createArrayU8Codec,
  createEnumCodec: () => createEnumCodec,
  createMapCodec: () => createMapCodec,
  createOptionCodec: () => createOptionCodec,
  createResultCodec: () => createResultCodec,
  createSetCodec: () => createSetCodec,
  createStructCodec: () => createStructCodec,
  createTupleCodec: () => createTupleCodec,
  createVecCodec: () => createVecCodec,
  dynCodec: () => dynCodec,
  formatWalkerStep: () => formatWalkerStep,
  getCurrentTracker: () => getCurrentTracker,
  isTrackValueInspectable: () => isTrackValueInspectable,
  setCurrentTracker: () => setCurrentTracker,
  trackDecode: () => trackDecode,
  trackRefineDecodeLoc: () => trackRefineDecodeLoc,
  trackableCodec: () => trackableCodec,
  tryInspectValue: () => tryInspectValue
});
module.exports = __toCommonJS(lib_exports);
__reExport(lib_exports, require("@scale-codec/core"), module.exports);

// packages/definition-runtime/src/core.ts
var import_core = require("@scale-codec/core");

// packages/definition-runtime/src/tracking/types.ts
var TrackValueInspect = Symbol("TrackValueInspect");

// packages/definition-runtime/src/tracking/current.ts
var __currentTracker = null;
function getCurrentTracker() {
  return __currentTracker;
}
function setCurrentTracker(tracker) {
  __currentTracker = tracker;
}
var trackDecode = (loc, walker, decode) => {
  return __currentTracker?.decode?.(loc, walker, decode) ?? decode(walker);
};
var trackRefineDecodeLoc = (loc, headlessDecode) => {
  return __currentTracker?.refineDecodeLoc?.(loc, headlessDecode) ?? headlessDecode();
};

// packages/definition-runtime/src/tracking/decode-trace.ts
var import_util2 = require("@scale-codec/util");
var import_fmt_subs = require("fmt-subs");

// packages/definition-runtime/src/tracking/util.ts
var import_util = require("@scale-codec/util");
var ELLIPSIS = "\u2026";
function formatU8(u8, start, end) {
  const hex = (0, import_util.toHex)(u8.subarray(Math.min(start, end ?? Infinity), Math.max(start, end ?? Infinity)));
  return `${start > 0 ? ELLIPSIS : ""}${hex}${typeof end === "number" && end < u8.length ? ELLIPSIS : ""}`;
}
function formatWalkerOffset(start, end) {
  const offsetValue = typeof end === "number" ? `${start}..${end}` : start;
  let deltaSuffix = "";
  if (typeof end === "number") {
    const delta = end - start;
    deltaSuffix = ` (${delta >= 0 ? `+${delta}` : delta})`;
  }
  return `offset: ${offsetValue}${deltaSuffix}`;
}
function formatWalkerStep(params) {
  return `${formatWalkerOffset(params.offsetStart, params.offsetEnd)}; ${formatU8(params.walker.u8, params.offsetStart, params.offsetEnd)}`;
}
function isTrackValueInspectable(value) {
  return typeof value === "object" && TrackValueInspect in value;
}
function tryInspectValue(value) {
  if (isTrackValueInspectable(value)) {
    return value[TrackValueInspect]();
  }
  return value;
}

// packages/definition-runtime/src/tracking/decode-trace.ts
var DecodeTrace = class {
  parent = null;
  loc;
  input;
  result;
  error;
  children = [];
  constructor(loc) {
    this.loc = [loc];
  }
  findRoot() {
    return this.parent ? this.parent.findRoot() : this;
  }
  get isRoot() {
    return !this.parent;
  }
  setParent(trace) {
    this.parent = trace;
    return this;
  }
  refineLoc(loc) {
    this.loc.push(loc);
    return this;
  }
  setInput(offset) {
    this.input = { offset };
    return this;
  }
};
var DecodeTraceCollector = class {
  current = null;
  decodeStart(loc, walker) {
    if (this.current && !this.current.input) {
      this.current.setInput(walker.idx).refineLoc(loc);
    } else {
      const newTrace = new DecodeTrace(loc).setInput(walker.idx);
      if (!this.current) {
        this.current = newTrace;
      } else {
        const child = newTrace.setParent(this.current);
        this.current.children.push(child);
        this.current = child;
      }
    }
  }
  decodeSuccess(walker, decodedValue) {
    (0, import_util2.assert)(this.current, "No current");
    this.current.result = { value: decodedValue, offset: walker.idx };
    if (!this.current.parent) {
      const trace = this.current;
      this.current = null;
      return trace;
    } else {
      this.current = this.current.parent;
      return null;
    }
  }
  decodeError(err) {
    (0, import_util2.assert)(this.current, "No current");
    this.current.error = err;
    return this.current.findRoot();
  }
  refineLoc(loc) {
    (0, import_util2.assert)(this.current, "No current");
    if (this.current.input) {
      const newTrace = new DecodeTrace(loc).setParent(this.current);
      this.current.children.push(newTrace);
      this.current = newTrace;
    } else {
      this.current.refineLoc(loc);
    }
  }
};
function tracePath(trace) {
  const path = [];
  for (let current = trace; current; current = current.parent) {
    for (let len = current.loc.length, i = len - 1; i >= 0; i--) {
      path.push(current.loc[i]);
    }
  }
  path.reverse();
  return path;
}
var INDENT = " ".repeat(4);
function buildStepsRecursive(trace, ctx) {
  const errored = !!trace.error;
  const resultVal = trace.result;
  const path = tracePath(trace).join(" / ");
  const result = errored ? import_fmt_subs.fmt`ERROR - ${(0, import_fmt_subs.sub)(trace.error, "%s")}` : resultVal ? (0, import_fmt_subs.sub)(tryInspectValue(resultVal.value), "%O") : "<not computed>";
  const walk = trace.input ? `<${formatWalkerStep({
    walker: ctx.walker,
    offsetStart: trace.input.offset,
    offsetEnd: trace.result?.offset
  })}>` : "<no input>";
  let acc = import_fmt_subs.Fmt.concat(import_fmt_subs.fmt`${path}\n`, import_fmt_subs.fmt`${INDENT}Walk: ${walk}\n`, import_fmt_subs.fmt`${INDENT}Result: ${result}\n`, import_fmt_subs.fmt`${INDENT}Child steps: ${trace.children.length}\n`);
  if (trace.children.length) {
    acc = acc.concat(...trace.children.map((x) => buildStepsRecursive(x, ctx)));
  }
  return acc;
}
function buildDecodeTraceStepsFmt(trace, walker) {
  return buildStepsRecursive(trace, { walker });
}

// packages/definition-runtime/src/tracking/logger.ts
var import_fmt_subs2 = require("fmt-subs");
function logError(format, ...args) {
  console.error(`[SCALE] ${format}`, ...args);
}
function logDebug(format, ...args) {
  console.debug(`[SCALE] ${format}`, ...args);
}
var Logger = class {
  config;
  decodeTracer = new DecodeTraceCollector();
  decodeCurrentDepth = 0;
  decodeErrorHandled = false;
  constructor(config) {
    this.config = config;
  }
  get logDecodeErrors() {
    return this.config?.logDecodeErrors ?? true;
  }
  get logDecodeOk() {
    return this.config?.logDecodeSuccesses ?? false;
  }
  decode(loc, walker, decode) {
    try {
      this.decodeCurrentDepth++;
      this.decodeTracer.decodeStart(loc, walker);
      const value = decode(walker);
      const maybeRootTrace = this.decodeTracer.decodeSuccess(walker, value);
      if (maybeRootTrace && this.logDecodeOk) {
        const tree = this.buildDecodeTree(maybeRootTrace, walker);
        logDebug(...import_fmt_subs2.fmt`Decode of "${maybeRootTrace.loc}" succeed\n\nDecode steps:\n\n${tree}`.assemble());
      }
      return value;
    } catch (err) {
      if (!this.decodeErrorHandled) {
        this.decodeErrorHandled = true;
        const trace = this.decodeTracer.decodeError(err);
        if (this.logDecodeErrors) {
          const tree = this.buildDecodeTree(trace, walker);
          logError(...import_fmt_subs2.fmt`Decode of "${trace.loc}" failed with error: ${err}\n\nDecode steps:\n\n${tree}`.assemble());
        }
      }
      throw err;
    } finally {
      if (!--this.decodeCurrentDepth) {
        this.decodeErrorHandled = false;
      }
    }
  }
  refineDecodeLoc(loc, decode) {
    this.decodeTracer.refineLoc(loc);
    return decode();
  }
  mount() {
    const current = getCurrentTracker();
    if (current && current !== this)
      throw new Error("Something is already mounted");
    if (!current) {
      setCurrentTracker(this);
    }
  }
  unmount() {
    const current = getCurrentTracker();
    if (current === this) {
      setCurrentTracker(null);
    }
    throw new Error("This tracker is not mounted");
  }
  buildDecodeTree(trace, walker) {
    return buildDecodeTraceStepsFmt(trace, walker);
  }
};

// packages/definition-runtime/src/core.ts
function trackableCodec(name, encode, decode) {
  const decodeTracked = (walker) => trackDecode(name, walker, decode);
  return {
    encodeRaw: encode,
    decodeRaw: decodeTracked,
    toBuffer: (value) => import_core.WalkerImpl.encode(value, encode),
    fromBuffer: (src) => import_core.WalkerImpl.decode(src, decodeTracked)
  };
}
function dynCodec(getter) {
  let codec;
  const getCodec = () => {
    if (!codec) {
      codec = getter();
    }
    return codec;
  };
  return {
    encodeRaw: (0, import_core.encodeFactory)((val, walker) => (codec ?? getCodec()).encodeRaw(val, walker), (val) => (codec ?? getCodec()).encodeRaw.sizeHint(val)),
    decodeRaw: (walker) => (codec ?? getCodec()).decodeRaw(walker),
    toBuffer: (value) => (codec ?? getCodec()).toBuffer(value),
    fromBuffer: (src) => (codec ?? getCodec()).fromBuffer(src)
  };
}

// packages/definition-runtime/src/create.ts
var import_core2 = require("@scale-codec/core");
var createYetAnotherOpaqueReturn = () => (actual) => actual;
var mergePropsWithFunction = (fn, props) => Object.assign(fn, props);
function createArrayCodec(name, itemCodec, len) {
  const define = createYetAnotherOpaqueReturn();
  const codec = trackableCodec(name, (0, import_core2.createArrayEncoder)(itemCodec.encodeRaw, len), (0, import_core2.createArrayDecoder)(itemCodec.decodeRaw, len));
  return mergePropsWithFunction(define, codec);
}
function createArrayU8Codec(name, len) {
  return trackableCodec(name, (0, import_core2.createUint8ArrayEncoder)(len), (0, import_core2.createUint8ArrayDecoder)(len));
}
function createVecCodec(name, itemCodec) {
  const codec = trackableCodec(name, (0, import_core2.createVecEncoder)(itemCodec.encodeRaw), (0, import_core2.createVecDecoder)(itemCodec.decodeRaw));
  const define = createYetAnotherOpaqueReturn();
  return mergePropsWithFunction(define, codec);
}
function createTupleCodec(name, codecs) {
  const encoders = [];
  const decoders = [];
  for (let i = 0, len = codecs.length, codec2 = codecs[i]; i < len; i++, codec2 = codecs[i]) {
    encoders.push(codec2.encodeRaw);
    decoders.push((walker) => trackRefineDecodeLoc(`<tuple>.${i}`, () => codec2.decodeRaw(walker)));
  }
  const codec = trackableCodec(name, (0, import_core2.createTupleEncoder)(encoders), (0, import_core2.createTupleDecoder)(decoders));
  const define = createYetAnotherOpaqueReturn();
  return mergePropsWithFunction(define, codec);
}
var simpleEnumFactory = (...args) => import_core2.Enum.variant(...args);
function createEnumCodec(name, schema) {
  const encoders = {};
  const decoders = {};
  for (const [dis, tag, codec2] of schema) {
    ;
    encoders[tag] = codec2 ? [dis, codec2.encodeRaw] : dis;
    decoders[dis] = codec2 ? [tag, (walker) => trackRefineDecodeLoc(`<enum>::${tag}`, () => codec2.decodeRaw(walker))] : tag;
  }
  const codec = trackableCodec(name, (0, import_core2.createEnumEncoder)(encoders), (0, import_core2.createEnumDecoder)(decoders));
  return mergePropsWithFunction(simpleEnumFactory.bind({}), codec);
}
function createOptionCodec(name, someCodec) {
  return createEnumCodec(name, [
    [0, "None"],
    [1, "Some", someCodec]
  ]);
}
function createResultCodec(name, okCodec, errCodec) {
  return createEnumCodec(name, [
    [0, "Ok", okCodec],
    [1, "Err", errCodec]
  ]);
}
function createStructCodec(name, orderedCodecs) {
  const decoders = [];
  const encoders = [];
  for (const [field, codec2] of orderedCodecs) {
    decoders.push([field, (walker) => trackRefineDecodeLoc(`<struct>.${field}`, () => codec2.decodeRaw(walker))]);
    encoders.push([field, codec2.encodeRaw]);
  }
  const codec = trackableCodec(name, (0, import_core2.createStructEncoder)(encoders), (0, import_core2.createStructDecoder)(decoders));
  return mergePropsWithFunction(createYetAnotherOpaqueReturn(), codec);
}
function createMapCodec(name, keyCodec, valueCodec) {
  const codec = trackableCodec(name, (0, import_core2.createMapEncoder)(keyCodec.encodeRaw, valueCodec.encodeRaw), (0, import_core2.createMapDecoder)((walker) => trackRefineDecodeLoc("<map>.<key>", () => keyCodec.decodeRaw(walker)), (walker) => trackRefineDecodeLoc("<map>.<value>", () => valueCodec.decodeRaw(walker))));
  return mergePropsWithFunction(createYetAnotherOpaqueReturn(), codec);
}
function createSetCodec(name, itemCodec) {
  const codec = trackableCodec(name, (0, import_core2.createSetEncoder)(itemCodec.encodeRaw), (0, import_core2.createSetDecoder)(itemCodec.decodeRaw));
  return mergePropsWithFunction(createYetAnotherOpaqueReturn(), codec);
}

// packages/definition-runtime/src/codecs.ts
var import_core4 = require("@scale-codec/core");
var U8 = trackableCodec("u8", import_core4.encodeU8, import_core4.decodeU8);
var I8 = trackableCodec("i8", import_core4.encodeI8, import_core4.decodeI8);
var U16 = trackableCodec("u16", import_core4.encodeU16, import_core4.decodeU16);
var I16 = trackableCodec("i16", import_core4.encodeI16, import_core4.decodeI16);
var U32 = trackableCodec("u32", import_core4.encodeU32, import_core4.decodeU32);
var I32 = trackableCodec("i32", import_core4.encodeI32, import_core4.decodeI32);
var U64 = trackableCodec("u64", import_core4.encodeU64, import_core4.decodeU64);
var I64 = trackableCodec("i64", import_core4.encodeI64, import_core4.decodeI64);
var U128 = trackableCodec("u128", import_core4.encodeU128, import_core4.decodeU128);
var I128 = trackableCodec("i128", import_core4.encodeI128, import_core4.decodeI128);
var Str = trackableCodec("str", import_core4.encodeStr, import_core4.decodeStr);
var Bool = trackableCodec("bool", import_core4.encodeBool, import_core4.decodeBool);
var Void = trackableCodec("void", import_core4.encodeVoid, import_core4.decodeVoid);
var VecU8 = trackableCodec("VecU8", import_core4.encodeUint8Vec, import_core4.decodeUint8Vec);
var Compact = trackableCodec("compact", import_core4.encodeCompact, import_core4.decodeCompact);
