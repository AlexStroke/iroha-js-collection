/**
 * Core SCALE library with tools to encode to and decode SCALE binaries. It includes implementations for
 * primitive types as well as for complex types.
 *
 * @packageDocumentation
 */

import { Enum } from '@scale-codec/enum';
import { EnumDef } from '@scale-codec/enum';
import { EnumGenericDef } from '@scale-codec/enum';
import { Option as Option_2 } from '@scale-codec/enum';
import { Result } from '@scale-codec/enum';
import { TagsEmpty } from '@scale-codec/enum';
import { TagsValuable } from '@scale-codec/enum';
import { TagValue } from '@scale-codec/enum';

/**
 * Set of integer types that are supported by codec for `bigint`
 */
export declare type BigIntTypes = IntTypes | `${'i' | 'u'}${64 | 128 | 256 | 512}`;

export declare function countPositiveBigIntEffectiveBytes(positiveNum: bigint): number;

export declare function createArrayDecoder<T>(decodeItem: Decode<T>, len: number): Decode<T[]>;

export declare function createArrayEncoder<T>(encodeItem: Encode<T>, len: number): Encode<T[]>;

export declare function createBigIntDecoder(ty: BigIntTypes): Decode<bigint>;

export declare function createBigIntEncoder(ty: BigIntTypes): Encode<bigint>;

export declare function createEnumDecoder<E extends Enum<any>>(decoders: EnumDecoders<EnumDef<E>>): Decode<E>;

export declare function createEnumEncoder<E extends Enum<any>>(encoders: EnumEncoders<EnumDef<E>>): Encode<E>;

export declare function createIntDecoder(ty: IntTypes): Decode<number>;

export declare function createIntEncoder(ty: IntTypes): Encode<number>;

export declare function createMapDecoder<K, V>(decodeKey: Decode<K>, decodeValue: Decode<V>): Decode<Map<K, V>>;

export declare function createMapEncoder<K, V>(encodeKey: Encode<K>, encodeValue: Encode<V>): Encode<Map<K, V>>;

export declare function createOptionDecoder<T extends Option_2<any>>(decodeSome: Decode<OptionSome<T>>): Decode<T>;

export declare function createOptionEncoder<T extends Option_2<any>>(encodeSome: Encode<OptionSome<T>>): Encode<T>;

export declare function createResultDecoder<T extends Result<any, any>>(decodeOk: Decode<ResultOk<T>>, decodeErr: Decode<ResultErr<T>>): Decode<T>;

export declare function createResultEncoder<T extends Result<any, any>>(encodeOk: Encode<ResultOk<T>>, encodeErr: Encode<ResultErr<T>>): Encode<T>;

export declare function createSetDecoder<T>(decodeItem: Decode<T>): Decode<Set<T>>;

export declare function createSetEncoder<T>(encodeItem: Encode<T>): Encode<Set<T>>;

export declare function createStructDecoder<T extends {}>(decoders: StructDecoders<T>): Decode<T>;

export declare function createStructEncoder<T extends {}>(encoders: StructEncoders<T>): Encode<T>;

export declare function createTupleDecoder<T extends any[]>(decoders: TupleDecoders<T>): Decode<T>;

export declare function createTupleEncoder<T extends any[]>(encoders: TupleEncoders<T>): Encode<T>;

export declare function createUint8ArrayDecoder(len: number): Decode<Uint8Array>;

export declare function createUint8ArrayEncoder(len: number): Encode<Uint8Array>;

export declare function createVecDecoder<T>(decodeItem: Decode<T>): Decode<T[]>;

export declare function createVecEncoder<T>(encodeItem: Encode<T>): Encode<T[]>;

export declare type Decode<T> = (walker: Walker) => T;

export declare function decodeArray<T>(walker: Walker, decodeItem: Decode<T>, len: number): T[];

/**
 * Decodes `bigint` in Little-Endian
 */
export declare function decodeBigInt(walker: Walker, ty: BigIntTypes): bigint;

/**
 * Decodes `bigint` in Little-Endian. It is like {@link decodeBigInt} but is not
 * binded to strict bytes count (1, 2, 4, 8, 16 etc)
 *
 * @remarks
 * Does not mutate walker's offset!
 */
export declare function decodeBigIntVarious(walker: Walker, bytes: number, signed: boolean): bigint;

export declare const decodeBool: Decode<boolean>;

/**
 * Decodes compact-encoded integer
 */
export declare function decodeCompact(walker: Walker): bigint;

export declare function decodeEnum<E extends Enum<any>>(walker: Walker, decoders: EnumDecoders<EnumDef<E>>): E;

export declare const decodeI128: Decode<bigint>;

export declare const decodeI16: Decode<number>;

export declare const decodeI32: Decode<number>;

export declare const decodeI64: Decode<bigint>;

export declare const decodeI8: Decode<number>;

/**
 * Decodes signed/unsigned 8/16/32 bits integers in Little-Endian
 */
export declare function decodeInt(walker: Walker, ty: IntTypes): number;

export declare function decodeMap<K, V>(walker: Walker, decodeKey: Decode<K>, decodeValue: Decode<V>): Map<K, V>;

/**
 * Special decoder for `OptionBool` type from Rust's parity_scale_codec
 */
export declare const decodeOptionBool: Decode<Option_2<boolean>>;

export declare function decodeSet<T>(walker: Walker, decodeItem: Decode<T>): Set<T>;

export declare function decodeStr(walker: Walker): string;

export declare function decodeStruct<T extends {}>(walker: Walker, decoders: StructDecoders<T>): T;

declare type DecodeTuple<T extends string, V> = [tag: T, decode: Decode<V>];

export declare function decodeTuple<T extends any[]>(walker: Walker, decoders: TupleDecoders<T>): T;

export declare const decodeU128: Decode<bigint>;

export declare const decodeU16: Decode<number>;

export declare const decodeU32: Decode<number>;

export declare const decodeU64: Decode<bigint>;

export declare const decodeU8: Decode<number>;

/**
 * decode `[u8; x]` array directly into the native `Uint8Array`
 */
export declare function decodeUint8Array(walker: Walker, len: number): Uint8Array;

export declare const decodeUint8Vec: Decode<Uint8Array>;

export declare function decodeVec<T>(walker: Walker, decodeItem: Decode<T>): T[];

/**
 * Decoder to handle void types like `()` from Rust
 */
export declare const decodeVoid: Decode<null>;

export declare type Encode<T> = {
    (value: T, walker: Walker): void;
    sizeHint: (value: T) => number;
};

export declare function encodeArray<T>(arr: T[], encodeItem: Encode<T>, len: number, walker: Walker): void;

export declare function encodeArraySizeHint<T>(arr: T[], encodeItem: Encode<T>, len: number): number;

/**
 * Encodes `bigint` in Little-Endian
 */
export declare function encodeBigInt(bi: bigint, ty: BigIntTypes, walker: Walker): void;

export declare const encodeBool: Encode<boolean>;

export declare const encodeCompact: Encode<bigint | number>;

export declare function encodeEnum<E extends Enum<any>>(value: E, encoders: EnumEncoders<EnumDef<E>>, walker: Walker): void;

export declare function encodeEnumSizeHint<E extends Enum<any>>(value: E, encoders: EnumEncoders<E extends Enum<infer D> ? D : never>): number;

export declare function encodeFactory<T>(fn: (value: T, walker: Walker) => void, sizeHint: (value: T) => number): Encode<T>;

export declare const encodeI128: Encode<bigint>;

export declare const encodeI16: Encode<number>;

export declare const encodeI32: Encode<number>;

export declare const encodeI64: Encode<bigint>;

export declare const encodeI8: Encode<number>;

/**
 * Encodes signed/unsigned 8/16/32 bits integers in Little-Endian
 */
export declare function encodeInt(value: number, ty: IntTypes, walker: Walker): void;

export declare function encodeMap<K, V>(map: Map<K, V>, encodeKey: Encode<K>, encodeValue: Encode<V>, walker: Walker): void;

export declare function encodeMapSizeHint<K, V>(map: Map<K, V>, encodeKey: Encode<K>, encodeValue: Encode<V>): number;

/**
 * Special encoder for `OptionBool` type from Rust's parity_scale_codec
 */
export declare const encodeOptionBool: Encode<Option_2<boolean>>;

export declare function encodePositiveBigIntInto(positiveNum: bigint, mutSlice: Uint8Array, offset: number, bytesLimit: number): number;

export declare function encodeSet<T>(set: Set<T>, encodeItem: Encode<T>, walker: Walker): void;

export declare function encodeSetSizeHint<T>(set: Set<T>, encodeItem: Encode<T>): number;

export declare const encodeStr: Encode<string>;

export declare function encodeStruct<T extends {}>(struct: T, encoders: StructEncoders<T>, walker: Walker): void;

export declare function encodeStructSizeHint<T extends {}>(struct: T, encoders: StructEncoders<T>): number;

declare type EncodeTuple<V> = [discriminant: number, encode: Encode<V>];

export declare function encodeTuple<T extends any[]>(tuple: T, encoders: TupleEncoders<T>, walker: Walker): void;

export declare function encodeTupleSizeHint<T extends any[]>(tuple: T, encoders: TupleEncoders<T>): number;

export declare const encodeU128: Encode<bigint>;

export declare const encodeU16: Encode<number>;

export declare const encodeU32: Encode<number>;

export declare const encodeU64: Encode<bigint>;

export declare const encodeU8: Encode<number>;

/**
 * Encode to `[u8; x]` Rust's array directly from the native `Uint8Array`
 */
export declare function encodeUint8Array(value: Uint8Array, len: number, walker: Walker): void;

export declare const encodeUint8Vec: Encode<Uint8Array>;

export declare function encodeVec<T>(vec: T[], encodeItem: Encode<T>, walker: Walker): void;

export declare function encodeVecSizeHint<T>(vec: T[], encodeItem: Encode<T>): number;

/**
 * Encoder to handle void types like `()` from Rust
 */
export declare const encodeVoid: Encode<null>;

export declare type EnumDecoders<Def extends EnumGenericDef> = {
    [D in number]: TagsEmpty<Def> | (Def extends [infer T & string, infer V] ? DecodeTuple<T & string, V> : never);
};

export declare class EnumEncodeError extends Error {
    constructor(message: string, encoders: EnumEncoders<any>);
}

export declare type EnumEncoders<Def extends EnumGenericDef> = {
    [T in TagsEmpty<Def>]: number;
} & {
    [T in TagsValuable<Def>]: EncodeTuple<TagValue<Def, T>>;
};

/**
 * Set of integer types that are supported by codec for `number`
 */
export declare type IntTypes = `${'i' | 'u'}${8 | 16 | 32}`;

declare type OptionSome<T extends Option_2<any>> = T extends Option_2<infer V> ? V : never;

declare type ResultErr<T> = T extends Result<any, infer Err> ? Err : never;

declare type ResultOk<T> = T extends Result<infer Ok, any> ? Ok : never;

export declare class SliceWalkerFinalOffsetError extends Error {
    constructor(walker: Walker);
}

export declare type StructDecoders<T> = {
    [K in keyof T]: [K, Decode<T[K]>];
}[keyof T][];

export declare type StructEncoders<T> = {
    [K in keyof T]: [K, Encode<T[K]>];
}[keyof T][];

export declare type TupleDecoders<Tuple extends any[]> = Tuple extends [infer Head, ...infer Tail] ? [Decode<Head>, ...TupleDecoders<Tail>] : [];

export declare type TupleEncoders<Tuple extends any[]> = Tuple extends [infer Head, ...infer Tail] ? [Encode<Head>, ...TupleEncoders<Tail>] : [];

export declare interface Walker {
    u8: Uint8Array;
    view: DataView;
    idx: number;
}

export declare class WalkerImpl implements Walker {
    static encode<T>(value: T, encode: Encode<T>): Uint8Array;
    static decode<T>(source: ArrayBufferView, decode: Decode<T>): T;
    u8: Uint8Array;
    view: DataView;
    idx: number;
    constructor(source: ArrayBufferView);
    checkFinalOffset(): void;
    setOffset(value: number): this;
}


export * from "@scale-codec/enum";

export { }
