var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// packages/core/src/lib.ts
var lib_exports = {};
__export(lib_exports, {
  EnumEncodeError: () => EnumEncodeError,
  SliceWalkerFinalOffsetError: () => SliceWalkerFinalOffsetError,
  WalkerImpl: () => WalkerImpl,
  countPositiveBigIntEffectiveBytes: () => countPositiveBigIntEffectiveBytes,
  createArrayDecoder: () => createArrayDecoder,
  createArrayEncoder: () => createArrayEncoder,
  createBigIntDecoder: () => createBigIntDecoder,
  createBigIntEncoder: () => createBigIntEncoder,
  createEnumDecoder: () => createEnumDecoder,
  createEnumEncoder: () => createEnumEncoder,
  createIntDecoder: () => createIntDecoder,
  createIntEncoder: () => createIntEncoder,
  createMapDecoder: () => createMapDecoder,
  createMapEncoder: () => createMapEncoder,
  createOptionDecoder: () => createOptionDecoder,
  createOptionEncoder: () => createOptionEncoder,
  createResultDecoder: () => createResultDecoder,
  createResultEncoder: () => createResultEncoder,
  createSetDecoder: () => createSetDecoder,
  createSetEncoder: () => createSetEncoder,
  createStructDecoder: () => createStructDecoder,
  createStructEncoder: () => createStructEncoder,
  createTupleDecoder: () => createTupleDecoder,
  createTupleEncoder: () => createTupleEncoder,
  createUint8ArrayDecoder: () => createUint8ArrayDecoder,
  createUint8ArrayEncoder: () => createUint8ArrayEncoder,
  createVecDecoder: () => createVecDecoder,
  createVecEncoder: () => createVecEncoder,
  decodeArray: () => decodeArray,
  decodeBigInt: () => decodeBigInt,
  decodeBigIntVarious: () => decodeBigIntVarious,
  decodeBool: () => decodeBool,
  decodeCompact: () => decodeCompact,
  decodeEnum: () => decodeEnum,
  decodeI128: () => decodeI128,
  decodeI16: () => decodeI16,
  decodeI32: () => decodeI32,
  decodeI64: () => decodeI64,
  decodeI8: () => decodeI8,
  decodeInt: () => decodeInt,
  decodeMap: () => decodeMap,
  decodeOptionBool: () => decodeOptionBool,
  decodeSet: () => decodeSet,
  decodeStr: () => decodeStr,
  decodeStruct: () => decodeStruct,
  decodeTuple: () => decodeTuple,
  decodeU128: () => decodeU128,
  decodeU16: () => decodeU16,
  decodeU32: () => decodeU32,
  decodeU64: () => decodeU64,
  decodeU8: () => decodeU8,
  decodeUint8Array: () => decodeUint8Array,
  decodeUint8Vec: () => decodeUint8Vec,
  decodeVec: () => decodeVec,
  decodeVoid: () => decodeVoid,
  encodeArray: () => encodeArray,
  encodeArraySizeHint: () => encodeArraySizeHint,
  encodeBigInt: () => encodeBigInt,
  encodeBool: () => encodeBool,
  encodeCompact: () => encodeCompact,
  encodeEnum: () => encodeEnum,
  encodeEnumSizeHint: () => encodeEnumSizeHint,
  encodeFactory: () => encodeFactory,
  encodeI128: () => encodeI128,
  encodeI16: () => encodeI16,
  encodeI32: () => encodeI32,
  encodeI64: () => encodeI64,
  encodeI8: () => encodeI8,
  encodeInt: () => encodeInt,
  encodeMap: () => encodeMap,
  encodeMapSizeHint: () => encodeMapSizeHint,
  encodeOptionBool: () => encodeOptionBool,
  encodePositiveBigIntInto: () => encodePositiveBigIntInto,
  encodeSet: () => encodeSet,
  encodeSetSizeHint: () => encodeSetSizeHint,
  encodeStr: () => encodeStr,
  encodeStruct: () => encodeStruct,
  encodeStructSizeHint: () => encodeStructSizeHint,
  encodeTuple: () => encodeTuple,
  encodeTupleSizeHint: () => encodeTupleSizeHint,
  encodeU128: () => encodeU128,
  encodeU16: () => encodeU16,
  encodeU32: () => encodeU32,
  encodeU64: () => encodeU64,
  encodeU8: () => encodeU8,
  encodeUint8Array: () => encodeUint8Array,
  encodeUint8Vec: () => encodeUint8Vec,
  encodeVec: () => encodeVec,
  encodeVecSizeHint: () => encodeVecSizeHint,
  encodeVoid: () => encodeVoid
});
module.exports = __toCommonJS(lib_exports);

// packages/core/src/util.ts
var SliceWalkerFinalOffsetError = class extends Error {
  constructor(walker) {
    super(`offset (${walker.idx}) is not equal to array bytes length (${walker.u8.byteLength})`);
  }
};
var WalkerImpl = class {
  static encode(value, encode) {
    const walker = new WalkerImpl(new Uint8Array(encode.sizeHint(value)));
    encode(value, walker);
    walker.checkFinalOffset();
    return walker.u8;
  }
  static decode(source, decode) {
    const walker = new WalkerImpl(source);
    const value = decode(walker);
    walker.checkFinalOffset();
    return value;
  }
  u8;
  view;
  idx = 0;
  constructor(source) {
    if (!ArrayBuffer.isView(source))
      throw new Error(`Passed source is not an ArrayBufferView (${String(source)})`);
    this.u8 = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    this.view = new DataView(source.buffer, source.byteOffset, source.byteLength);
  }
  checkFinalOffset() {
    if (this.idx !== this.u8.byteLength)
      throw new SliceWalkerFinalOffsetError(this);
  }
  setOffset(value) {
    this.idx = value;
    return this;
  }
};
function encodeFactory(fn, sizeHint) {
  ;
  fn.sizeHint = sizeHint;
  return fn;
}

// packages/core/src/codecs/void.ts
var encodeVoid = encodeFactory(() => {
}, () => 0);
var decodeVoid = () => null;

// packages/core/src/codecs/bool.ts
var encodeBool = encodeFactory((value, walker) => {
  walker.u8[walker.idx++] = value ? 1 : 0;
}, () => 1);
var decodeBool = (walker) => walker.u8[walker.idx++] === 1;

// packages/core/src/codecs/int.ts
var import_util3 = require("@scale-codec/util");
var INT_BYTES_COUNT_MAP = {
  i8: 1,
  u8: 1,
  i16: 2,
  u16: 2,
  i32: 4,
  u32: 4,
  i64: 8,
  u64: 8,
  i128: 16,
  u128: 16,
  i256: 32,
  u256: 32,
  i512: 64,
  u512: 64
};
var tySizeHint = (ty) => () => INT_BYTES_COUNT_MAP[ty];
var isBigIntTyNativeSupported = (ty) => INT_BYTES_COUNT_MAP[ty] === 8;
var isIntTy = (ty) => INT_BYTES_COUNT_MAP[ty] <= 4;
var isIntTypeSigned = (ty) => ty[0] === "i";
function checkNegative(value, ty) {
  const isNegative = value < 0;
  const isTySigned = isIntTypeSigned(ty);
  (0, import_util3.assert)(!isNegative || isTySigned, () => `Negative num (${value}) is passed to unsigned ("${ty}") encoder`);
  return isNegative;
}
function encodeInt(value, ty, walker) {
  checkNegative(value, ty);
  (0, import_util3.assert)(Number.isSafeInteger(value), () => `Unsafe integer (${value}) is passed into encoder`);
  const { view, idx: offset } = walker;
  switch (ty) {
    case "i8":
      view.setInt8(offset, value);
      break;
    case "u8":
      view.setUint8(offset, value);
      break;
    case "i16":
      view.setInt16(offset, value, true);
      break;
    case "u16":
      view.setUint16(offset, value, true);
      break;
    case "i32":
      view.setInt32(offset, value, true);
      break;
    case "u32":
      view.setUint32(offset, value, true);
      break;
  }
  walker.idx += INT_BYTES_COUNT_MAP[ty];
}
function decodeInt(walker, ty) {
  const { view, idx: offset } = walker;
  let value;
  switch (ty) {
    case "i8":
      value = view.getInt8(offset);
      break;
    case "u8":
      value = view.getUint8(offset);
      break;
    case "i16":
      value = view.getInt16(offset, true);
      break;
    case "u16":
      value = view.getUint16(offset, true);
      break;
    case "i32":
      value = view.getInt32(offset, true);
      break;
    case "u32":
      value = view.getUint32(offset, true);
      break;
  }
  walker.idx += INT_BYTES_COUNT_MAP[ty];
  return value;
}
function encodeBINativeSupported(bi, ty, walker) {
  checkNegative(bi, ty);
  const { view, idx: offset } = walker;
  switch (ty) {
    case "u64":
      view.setBigUint64(offset, bi, true);
      break;
    case "i64":
      view.setBigInt64(offset, bi, true);
      break;
  }
  walker.idx += INT_BYTES_COUNT_MAP[ty];
}
function decodeBINativeSupported(walker, ty) {
  const { view, idx: offset } = walker;
  let value;
  switch (ty) {
    case "u64":
      value = view.getBigUint64(offset, true);
      break;
    case "i64":
      value = view.getBigInt64(offset, true);
      break;
  }
  walker.idx += INT_BYTES_COUNT_MAP[ty];
  return value;
}
function encodePositiveBigIntInto(positiveNum, mutSlice, offset, bytesLimit) {
  let i = 0;
  while (positiveNum > 0 && i < bytesLimit) {
    mutSlice[offset + i++] = Number(positiveNum & 0xffn);
    positiveNum >>= 8n;
  }
  if (positiveNum > 0) {
    throw new Error(`Number ${positiveNum} is out of bytes limit (${bytesLimit})`);
  }
  return i;
}
function countPositiveBigIntEffectiveBytes(positiveNum) {
  let count = 0;
  while (positiveNum > 0) {
    count++;
    positiveNum >>= 8n;
  }
  return count;
}
function encodeBigInt(bi, ty, walker) {
  if (isIntTy(ty)) {
    return encodeInt(Number(bi), ty, walker);
  }
  if (isBigIntTyNativeSupported(ty)) {
    return encodeBINativeSupported(bi, ty, walker);
  }
  const isNegative = checkNegative(bi, ty);
  const bytes = INT_BYTES_COUNT_MAP[ty];
  isNegative && (bi = BigInt.asUintN(bytes * 8, bi));
  encodePositiveBigIntInto(bi, walker.u8, walker.idx, bytes);
  walker.idx += bytes;
}
function decodeBigIntVarious(walker, bytes, signed) {
  let isNegative = signed && (walker.u8[walker.idx + bytes - 1] & 128) >> 7 === 1;
  let value = 0n;
  for (let i = 0, shift = 0n; i < bytes; i++, shift += 8n) {
    value += BigInt(walker.u8[walker.idx + i]) << shift;
  }
  isNegative && (value = BigInt.asIntN(bytes * 8, value));
  return value;
}
function decodeBigInt(walker, ty) {
  if (isIntTy(ty)) {
    return BigInt(decodeInt(walker, ty));
  }
  if (isBigIntTyNativeSupported(ty)) {
    return decodeBINativeSupported(walker, ty);
  }
  const isTySigned = isIntTypeSigned(ty);
  const bytes = INT_BYTES_COUNT_MAP[ty];
  const value = decodeBigIntVarious(walker, bytes, isTySigned);
  walker.idx += bytes;
  return value;
}
function createIntEncoder(ty) {
  return encodeFactory((value, writer) => encodeInt(value, ty, writer), tySizeHint(ty));
}
function createIntDecoder(ty) {
  return (reader) => decodeInt(reader, ty);
}
function createBigIntEncoder(ty) {
  return encodeFactory((value, writer) => encodeBigInt(value, ty, writer), tySizeHint(ty));
}
function createBigIntDecoder(ty) {
  return (reader) => decodeBigInt(reader, ty);
}
var encodeU8 = createIntEncoder("u8");
var decodeU8 = createIntDecoder("u8");
var encodeI8 = createIntEncoder("i8");
var decodeI8 = createIntDecoder("i8");
var encodeU16 = createIntEncoder("u16");
var decodeU16 = createIntDecoder("u16");
var encodeI16 = createIntEncoder("i16");
var decodeI16 = createIntDecoder("i16");
var encodeU32 = createIntEncoder("u32");
var decodeU32 = createIntDecoder("u32");
var encodeI32 = createIntEncoder("i32");
var decodeI32 = createIntDecoder("i32");
var encodeU64 = createBigIntEncoder("u64");
var decodeU64 = createBigIntDecoder("u64");
var encodeI64 = createBigIntEncoder("i64");
var decodeI64 = createBigIntDecoder("i64");
var encodeU128 = createBigIntEncoder("u128");
var decodeU128 = createBigIntDecoder("u128");
var encodeI128 = createBigIntEncoder("i128");
var decodeI128 = createBigIntDecoder("i128");

// packages/core/src/codecs/compact.ts
var MAX_U8 = 2 ** (8 - 2) - 1;
var MAX_U16 = 2 ** (16 - 2) - 1;
var MAX_U32 = 2 ** (32 - 2) - 1;
function decodeCompact(walker) {
  const firstByte = walker.u8[walker.idx];
  const flag = firstByte & 3;
  switch (flag) {
    case 0:
      walker.idx++;
      return BigInt(firstByte >> 2);
    case 1:
      return decodeBigInt(walker, "u16") >> 2n;
    case 2:
      return decodeBigInt(walker, "u32") >> 2n;
    default: {
      const bytesCount = (firstByte >> 2) + 4;
      walker.idx++;
      const value = decodeBigIntVarious(walker, bytesCount, false);
      walker.idx += bytesCount;
      return value;
    }
  }
}
function compactSizeHint(value) {
  if (value <= MAX_U8) {
    return 1;
  }
  if (value <= MAX_U16) {
    return 2;
  }
  if (value <= MAX_U32) {
    return 4;
  }
  return 1 + countPositiveBigIntEffectiveBytes(BigInt(value));
}
var encodeCompact = (value, walker) => {
  if (!(value >= 0 && (Number.isInteger(value) || typeof value === "bigint")))
    throw new Error(`Invalid number is passed: ${value}. It should be non-negative integer.`);
  if (value <= MAX_U8) {
    walker.u8[walker.idx++] = Number(value) << 2;
    return;
  }
  if (value <= MAX_U16) {
    encodeBigInt((BigInt(value) << 2n) + 0b01n, "u16", walker);
    return;
  }
  if (value <= MAX_U32) {
    encodeBigInt((BigInt(value) << 2n) + 0b10n, "u32", walker);
    return;
  }
  const bytesLength = encodePositiveBigIntInto(BigInt(value), walker.u8, walker.idx + 1, Infinity);
  walker.u8[walker.idx] = (bytesLength - 4 << 2) + 3;
  walker.idx += 1 + bytesLength;
};
encodeCompact.sizeHint = compactSizeHint;

// packages/core/src/codecs/array.ts
function encodeArray(arr, encodeItem, len, walker) {
  for (let i = 0; i < len; i++) {
    encodeItem(arr[i], walker);
  }
}
function encodeArraySizeHint(arr, encodeItem, len) {
  if (arr.length !== len)
    throw new Error(`[T; ${arr.length}] is passed to [T; ${len}] encoder`);
  let sum = 0;
  while (--len >= 0) {
    sum += encodeItem.sizeHint(arr[len]);
  }
  return sum;
}
function createArrayEncoder(encodeItem, len) {
  return encodeFactory((arr, walker) => encodeArray(arr, encodeItem, len, walker), (arr) => encodeArraySizeHint(arr, encodeItem, len));
}
function decodeArray(walker, decodeItem, len) {
  const arr = new Array(len);
  for (let i = 0; i < len; i++) {
    arr[i] = decodeItem(walker);
  }
  return arr;
}
function createArrayDecoder(decodeItem, len) {
  return (walker) => decodeArray(walker, decodeItem, len);
}
function encodeUint8Array(value, len, walker) {
  walker.u8.set(value, walker.idx);
  walker.idx += value.byteLength;
}
function createUint8ArrayEncoder(len) {
  return encodeFactory((value, walker) => encodeUint8Array(value, len, walker), (value) => {
    if (value.length !== len)
      throw new Error(`[u8; ${value.length}] is passed to [u8; ${len}] encoder`);
    return len;
  });
}
function decodeUint8Array(walker, len) {
  const availableBytesCount = walker.u8.byteLength - walker.idx;
  if (availableBytesCount < len)
    throw new Error(`[u8; ${availableBytesCount}] is passed to [u8; ${len}] decoder (len should be >= ${len})`);
  const value = walker.u8.slice(walker.idx, walker.idx + len);
  walker.idx += len;
  return value;
}
function createUint8ArrayDecoder(len) {
  return (walker) => decodeUint8Array(walker, len);
}

// packages/core/src/codecs/vec.ts
function encodeVec(vec, encodeItem, walker) {
  encodeCompact(BigInt(vec.length), walker);
  for (const item of vec) {
    encodeItem(item, walker);
  }
}
function encodeVecSizeHint(vec, encodeItem) {
  let size = encodeCompact.sizeHint(vec.length);
  for (let i = vec.length - 1; i >= 0; i--) {
    size += encodeItem.sizeHint(vec[i]);
  }
  return size;
}
function createVecEncoder(encodeItem) {
  return encodeFactory((vec, walker) => encodeVec(vec, encodeItem, walker), (vec) => encodeVecSizeHint(vec, encodeItem));
}
function decodeVec(walker, decodeItem) {
  const vecLength = decodeCompact(walker);
  return decodeArray(walker, decodeItem, Number(vecLength));
}
function createVecDecoder(decodeItem) {
  return (walker) => decodeVec(walker, decodeItem);
}
var encodeUint8Vec = encodeFactory((vec, walker) => {
  encodeCompact(vec.byteLength, walker);
  walker.u8.set(vec, walker.idx);
  walker.idx += vec.byteLength;
}, (vec) => encodeCompact.sizeHint(vec.byteLength) + vec.byteLength);
var decodeUint8Vec = (walker) => {
  const len = Number(decodeCompact(walker));
  const vec = walker.u8.slice(walker.idx, walker.idx + len);
  walker.idx += len;
  return vec;
};

// packages/core/src/codecs/str.ts
var encoder = new TextEncoder();
var decoder = new TextDecoder("utf-8", {
  fatal: true
});
function decodeStr(walker) {
  const utf8Bytes = decodeUint8Vec(walker);
  const str = decoder.decode(utf8Bytes);
  return str;
}
function utf8ByteLength(str) {
  let acc = str.length;
  for (let i = str.length - 1; i >= 0; i--) {
    const code = str.charCodeAt(i);
    if (code > 127 && code <= 2047)
      acc++;
    else if (code > 2047 && code <= 65535)
      acc += 2;
    if (code >= 56320 && code <= 57343)
      i--;
  }
  return acc;
}
var encodeStr = encodeFactory((str, walker) => {
  const byteLength = utf8ByteLength(str);
  encodeCompact(byteLength, walker);
  const result = encoder.encodeInto(str, walker.u8.subarray(walker.idx));
  if (result.written !== byteLength)
    throw new Error(`SCALE internal error: counting of string bytes length is incorrect; string: "${str}"; actual bytes length: ${result.written}; computed: ${byteLength}; please report a bug.`);
  walker.idx += byteLength;
}, (str) => {
  const len = utf8ByteLength(str);
  return len + encodeCompact.sizeHint(len);
});

// packages/core/src/codecs/tuple.ts
function encodeTuple(tuple, encoders, walker) {
  for (let i = 0, len = tuple.length; i < len; i++) {
    ;
    encoders[i](tuple[i], walker);
  }
}
function encodeTupleSizeHint(tuple, encoders) {
  let size = 0, i = tuple.length;
  while (--i >= 0) {
    size += encoders[i].sizeHint(tuple[i]);
  }
  return size;
}
function decodeTuple(walker, decoders) {
  const tuple = new Array(decoders.length);
  for (let i = 0, len = tuple.length; i < len; i++) {
    tuple[i] = decoders[i](walker);
  }
  return tuple;
}
function createTupleEncoder(encoders) {
  return encodeFactory((tuple, walker) => encodeTuple(tuple, encoders, walker), (tuple) => encodeTupleSizeHint(tuple, encoders));
}
function createTupleDecoder(decoders) {
  return (walker) => decodeTuple(walker, decoders);
}

// packages/core/src/codecs/map.ts
function encodeMap(map, encodeKey, encodeValue, walker) {
  encodeCompact(map.size, walker);
  for (const kv of map) {
    encodeKey(kv[0], walker);
    encodeValue(kv[1], walker);
  }
}
function encodeMapSizeHint(map, encodeKey, encodeValue) {
  let size = encodeCompact.sizeHint(map.size);
  for (const key of map.keys()) {
    size += encodeKey.sizeHint(key);
  }
  for (const value of map.values()) {
    size += encodeValue.sizeHint(value);
  }
  return size;
}
function decodeMap(walker, decodeKey, decodeValue) {
  let mapSize = Number(decodeCompact(walker));
  const map = /* @__PURE__ */ new Map();
  while (--mapSize >= 0) {
    map.set(decodeKey(walker), decodeValue(walker));
  }
  return map;
}
function createMapEncoder(encodeKey, encodeValue) {
  return encodeFactory((map, walker) => encodeMap(map, encodeKey, encodeValue, walker), (map) => encodeMapSizeHint(map, encodeKey, encodeValue));
}
function createMapDecoder(decodeKey, decodeValue) {
  return (walker) => decodeMap(walker, decodeKey, decodeValue);
}

// packages/core/src/codecs/struct.ts
function encodeStruct(struct, encoders, walker) {
  for (let i = 0, len = encoders.length, encoder2 = null; i < len; i++) {
    encoder2 = encoders[i];
    encoder2[1](struct[encoder2[0]], walker);
  }
}
function encodeStructSizeHint(struct, encoders) {
  let sum = 0;
  for (let i = encoders.length - 1, encoder2 = null; i >= 0; i--) {
    encoder2 = encoders[i];
    sum += encoder2[1].sizeHint(struct[encoder2[0]]);
  }
  return sum;
}
function createStructEncoder(encoders) {
  return encodeFactory((val, walker) => encodeStruct(val, encoders, walker), (val) => encodeStructSizeHint(val, encoders));
}
function decodeStruct(walker, decoders) {
  const struct = {};
  for (let i = 0, len = decoders.length, decoder2 = null; i < len; i++) {
    decoder2 = decoders[i];
    struct[decoder2[0]] = decoder2[1](walker);
  }
  return struct;
}
function createStructDecoder(decoders) {
  return (walker) => decodeStruct(walker, decoders);
}

// packages/core/src/codecs/enum.ts
var import_enum = require("@scale-codec/enum");
var getEncodeData = (encoders, key) => {
  const item = encoders[key];
  if (typeof item === "number")
    return [item];
  if (!item)
    return null;
  return item;
};
function normalizeDecodeTuple(tuple) {
  return typeof tuple === "string" ? [tuple] : tuple;
}
var formatEncodersSchema = (encoders) => {
  return Object.entries(encoders).map(([tag, encodeData]) => {
    const [discriminant, isValuable] = typeof encodeData === "number" ? [encodeData, false] : [encodeData[0], true];
    const maybeTagSuffix = isValuable ? "(...)" : "";
    return `${tag}${maybeTagSuffix} => ${discriminant}`;
  }).join(", ");
};
var EnumEncodeError = class extends Error {
  constructor(message, encoders) {
    super(message + `; encoders schema: ${formatEncodersSchema(encoders)}`);
  }
};
function encodeEnum(value, encoders, walker) {
  const [dis, encode] = getEncodeData(encoders, value.tag);
  walker.u8[walker.idx++] = dis;
  if (encode) {
    encode(value.value, walker);
  }
}
function encodeEnumSizeHint(value, encoders) {
  const { tag, isEmpty } = value;
  const encodeData = getEncodeData(encoders, tag);
  if (encodeData === null)
    throw new EnumEncodeError(`Invalid encode schema for Enum with tag "${tag}": ${encoders[tag]}`, encoders);
  const [, encode] = encodeData;
  if (encode) {
    if (isEmpty)
      throw new EnumEncodeError(`Enum with tag "${tag}" is empty, but supposed not to be`, encoders);
    return 1 + encode.sizeHint(value.value);
  }
  if (!isEmpty)
    throw new EnumEncodeError(`Enum with tag "${tag}" is not empty, but supposed to be`, encoders);
  return 1;
}
function createEnumEncoder(encoders) {
  return encodeFactory((val, walker) => encodeEnum(val, encoders, walker), (val) => encodeEnumSizeHint(val, encoders));
}
function formatDecoders(decoders) {
  return Object.entries(decoders).map(([discriminant, varAndDecoder]) => {
    const [tag, decode] = normalizeDecodeTuple(varAndDecoder);
    let right = tag;
    if (decode) {
      right += "(...)";
    }
    return `${discriminant} => ${right}`;
  }).join(", ");
}
function decodeEnum(walker, decoders) {
  const discriminant = walker.u8[walker.idx++];
  const decoder2 = decoders[discriminant];
  if (!decoder2)
    throw new Error(`Decode data for discriminant ${discriminant} is undefined; decoders schema: ${formatDecoders(decoders)}`);
  const [tag, decode] = normalizeDecodeTuple(decoder2);
  if (decode)
    return import_enum.Enum.variant(tag, decode(walker));
  return import_enum.Enum.variant(tag);
}
function createEnumDecoder(decoders) {
  return (walker) => decodeEnum(walker, decoders);
}
function createOptionEncoder(encodeSome) {
  return createEnumEncoder({
    None: 0,
    Some: [1, encodeSome]
  });
}
function createOptionDecoder(decodeSome) {
  return createEnumDecoder({
    0: "None",
    1: ["Some", decodeSome]
  });
}
function createResultEncoder(encodeOk, encodeErr) {
  return createEnumEncoder({
    Ok: [0, encodeOk],
    Err: [1, encodeErr]
  });
}
function createResultDecoder(decodeOk, decodeErr) {
  return createEnumDecoder({
    0: ["Ok", decodeOk],
    1: ["Err", decodeErr]
  });
}
function optBoolByteToEnum(byte) {
  switch (byte) {
    case 0:
      return import_enum.Enum.variant("None");
    case 1:
      return import_enum.Enum.variant("Some", true);
    case 2:
      return import_enum.Enum.variant("Some", false);
    default:
      throw new Error(`Failed to decode OptionBool - byte is ${byte}`);
  }
}
var encodeOptionBool = encodeFactory((value, walker) => {
  walker.u8[walker.idx++] = value.is("None") ? 0 : value.as("Some") ? 1 : 2;
}, () => 1);
var decodeOptionBool = (walker) => optBoolByteToEnum(walker.u8[walker.idx++]);

// packages/core/src/codecs/set.ts
function encodeSet(set, encodeItem, walker) {
  encodeCompact(set.size, walker);
  for (const item of set) {
    encodeItem(item, walker);
  }
}
function encodeSetSizeHint(set, encodeItem) {
  let size = encodeCompact.sizeHint(set.size);
  for (const item of set) {
    size += encodeItem.sizeHint(item);
  }
  return size;
}
function decodeSet(walker, decodeItem) {
  let setSize = Number(decodeCompact(walker));
  const set = /* @__PURE__ */ new Set();
  while (--setSize >= 0) {
    set.add(decodeItem(walker));
  }
  return set;
}
function createSetEncoder(encodeItem) {
  return encodeFactory((set, walker) => encodeSet(set, encodeItem, walker), (set) => encodeSetSizeHint(set, encodeItem));
}
function createSetDecoder(decodeItem) {
  return (walker) => decodeSet(walker, decodeItem);
}

// packages/core/src/lib.ts
__reExport(lib_exports, require("@scale-codec/enum"), module.exports);
