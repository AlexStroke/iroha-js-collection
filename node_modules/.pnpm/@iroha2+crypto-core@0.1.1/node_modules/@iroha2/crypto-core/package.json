{
  "name": "@iroha2/crypto-core",
  "version": "0.1.1",
  "license": "Apache 2.0",
  "main": "dist/index.d.ts",
  "readme": "# @iroha2/crypto-core\n\nCore Iroha v2 JS Crypto package. Contains unified crypto interface. Compiled implementations for each target are in their own packages, accordingly:\n\n-   `@iroha2/crypto-target-node`\n-   `@iroha2/crypto-target-web`\n-   `@iroha2/crypto-target-bundler`\n\nMore about targets in [the `wasm-bindgen`'s docs](https://rustwasm.github.io/docs/wasm-bindgen/reference/deployment.html).\n\n## Installation\n\n```ini\n# .npmrc\n@iroha2:registry=https://nexus.iroha.tech/repository/npm-group/\n```\n\n```shell\n# install necessary packages\npnpm add @iroha2/crypto-core @iroha2/crypto-target-node\n```\n\n## How to develop libraries that would depend on Iroha Crypto?\n\nThere is the only way (as I see it) now to develop a library that will be environment-agnostic. You have to use dependency-inversion strategy - make your library depend on the interface `IrohaCryptoInterface` instead of a particular implementation. For example:\n\n```ts\nimport { IrohaCryptoInterface } from '@iroha2/crypto-core';\n\ninterface MyEmailHashingLibrary {\n    hash(email: string): Uint8Array;\n}\n\nfunction encodeString(str: string): Uint8Array {\n    /* making utf-8 magic... */\n}\n\n/**\n * Injecting crypto in runtime as an argument\n */\nexport function createEmailHashing(crypto: IrohaCryptoInterface): MyEmailHashingLibrary {\n    return {\n        hash(email) {\n            // and using crypto\n            const hash = crypto.createHash(encodeString(email));\n            const bytes = hash.bytes();\n            // also don't forget to `free` structures from the wasm to avoid memory leaks!\n            hash.free();\n            return bytes;\n        },\n    };\n}\n```\n"
}