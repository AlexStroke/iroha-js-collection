/**
 * Runtime for the output of `@scale-codec/definition-compiler`
 *
 * @remarks
 * Reexports the whole core library and defines codecs for STD types.
 *
 * @packageDocumentation
 */

import { Decode } from '@scale-codec/core';
import { Encode } from '@scale-codec/core';
import { Enum } from '@scale-codec/core';
import { EnumDefToFactoryArgs } from '@scale-codec/core';
import { Fmt } from 'fmt-subs';
import { Opaque } from 'type-fest';
import { Option as Option_2 } from '@scale-codec/core';
import { Result } from '@scale-codec/core';
import { Walker } from '@scale-codec/core';

export declare type ArrayCodecAndFactory<T extends Array<any>, U extends OpaqueRecursive<T>> = Codec<U> & DefineOpaque<T, U>;

export declare type Bool = boolean;

export declare const Bool: Codec<boolean, boolean>;

/**
 * @remarks
 * This function shouldn't be in the `DecodeTrace` class itself due to provide a tree-shaking possibility. This is not
 * the main part of this class, but the side tool, used for pretty-print in the console.
 */
export declare function buildDecodeTraceStepsFmt(trace: DecodeTrace, walker: Walker): Fmt;

/**
 * General interface for any codec
 */
export declare interface Codec<Encoded, Decoded = Encoded> {
    encodeRaw: Encode<Encoded>;
    decodeRaw: Decode<Decoded>;
    fromBuffer: (src: ArrayBufferView) => Decoded;
    toBuffer: (value: Encoded) => Uint8Array;
}

export declare type CodecAny = Codec<any, any>;

/**
 * Instance that defines method to track decoding flow
 */
export declare interface CodecTracker {
    /**
     * Used to track decode step: location, input, and result
     */
    decode?: TrackDecodeFn;
    /**
     * Used to clarify decode location without tracking of the input and the output
     */
    refineDecodeLoc?: RefineDecodeLocFn;
}

export declare type CodecValueDecoded<T extends Codec<any>> = T extends Codec<any, infer D> ? D : never;

export declare type CodecValueEncodable<T extends Codec<any>> = T extends Codec<infer E, any> ? E : never;

export declare type Compact = bigint;

export declare const Compact: Codec<bigint, bigint>;

export declare function createArrayCodec<T extends Array<any>, U extends OpaqueRecursive<T>>(name: string, itemCodec: Codec<T extends Array<infer I> ? I : never>, len: number): ArrayCodecAndFactory<T, U>;

export declare function createArrayU8Codec(name: string, len: number): Codec<Uint8Array>;

export declare function createEnumCodec<T extends Enum<any>, U extends Opaque<T, T>>(name: string, schema: EnumDefAsSchema<T>): EnumCodecAndFactory<U>;

export declare function createMapCodec<T extends Map<any, any>, U extends Opaque<T, T>>(name: string, keyCodec: Codec<T extends Map<infer K, any> ? K : never>, valueCodec: Codec<T extends Map<any, infer V> ? V : never>): MapCodecAndFactory<T, U>;

export declare function createOptionCodec<T extends Option_2<any>, U extends Opaque<T, T>>(name: string, someCodec: Codec<T extends Option_2<infer V> ? V : never>): EnumCodecAndFactory<U>;

export declare function createResultCodec<T extends Result<any, any>, U extends OpaqueRecursive<T>>(name: string, okCodec: Codec<T extends Result<infer Ok, any> ? Ok : never>, errCodec: Codec<T extends Result<any, infer Err> ? Err : never>): EnumCodecAndFactory<U>;

export declare function createSetCodec<T extends Set<any>, U extends Opaque<T, T>>(name: string, itemCodec: Codec<T extends Set<infer V> ? V : never>): SetCodecAndFactory<T, U>;

export declare function createStructCodec<T, U extends Opaque<T, T>>(name: string, orderedCodecs: StructCodecsSchema<T>): StructCodecAndFactory<T, U>;

export declare function createTupleCodec<T extends Array<any>, U extends Opaque<T, T>>(name: string, codecs: TupleCodecs<T>): Codec<U> & DefineOpaque<T, U>;

export declare function createVecCodec<T extends any[], U extends OpaqueRecursive<T>>(name: string, itemCodec: Codec<T extends (infer V)[] ? V : never>): ArrayCodecAndFactory<T, U>;

export declare class DecodeTrace {
    parent: DecodeTrace | null;
    /**
     * Location
     */
    loc: string[];
    input?: {
        offset: number;
    };
    result?: {
        offset: number;
        value: unknown;
    };
    error?: unknown;
    children: DecodeTrace[];
    constructor(loc: string);
    findRoot(): DecodeTrace;
    get isRoot(): boolean;
    setParent(trace: DecodeTrace): this;
    refineLoc(loc: string): this;
    setInput(offset: number): this;
}

export declare class DecodeTraceCollector {
    private current;
    decodeStart(loc: string, walker: Walker): void;
    /**
     * @returns the root decode trace if it was the root
     */
    decodeSuccess(walker: Walker, decodedValue: unknown): null | DecodeTrace;
    /**
     * @returns Returns root trace
     */
    decodeError(err: unknown): DecodeTrace;
    refineLoc(loc: string): void;
}

export declare type DefineOpaque<T, U extends Opaque<T, T>> = (actual: T) => U;

export declare function dynCodec<C extends CodecAny>(getter: () => C): Codec<CodecValueEncodable<C>, CodecValueDecoded<C>>;

export declare type EnumCodecAndFactory<T> = Codec<T> & EnumFactory<T>;

export declare type EnumDefAsSchema<T> = T extends Enum<infer Def> ? (Def extends string ? [discriminant: number, tag: Def] : Def extends [infer Tag, infer Value] ? [discriminant: number, tag: Tag, codec: Codec<Value>] : never)[] : never;

export declare type EnumFactory<T> = T extends Enum<infer Def> ? (...args: EnumDefToFactoryArgs<Def>) => T : never;

export declare function formatWalkerStep(params: FormatWalkerStepParams): string;

export declare interface FormatWalkerStepParams {
    walker: Walker;
    /**
     * The walker's offset at the start of the step
     */
    offsetStart: number;
    /**
     * The walker's offset at the end of the step
     */
    offsetEnd?: number;
}

/**
 * **Caution**: uses global state
 */
export declare function getCurrentTracker(): null | CodecTracker;

export declare type I128 = bigint;

export declare const I128: Codec<bigint, bigint>;

export declare type I16 = number;

export declare const I16: Codec<number, number>;

export declare type I32 = number;

export declare const I32: Codec<number, number>;

export declare type I64 = bigint;

export declare const I64: Codec<bigint, bigint>;

export declare type I8 = number;

export declare const I8: Codec<number, number>;

export declare function isTrackValueInspectable(value: unknown): value is TrackValueInspectable;

/**
 * Prints tracked info to console
 *
 * @example
 * ```ts
 * import { Logger } from 'lib'
 *
 * new Logger().mount()
 *
 * // use decoding functions and see console output
 * ```
 */
export declare class Logger implements CodecTracker {
    config?: LoggerConfig;
    private decodeTracer;
    private decodeCurrentDepth;
    private decodeErrorHandled;
    constructor(config?: LoggerConfig);
    private get logDecodeErrors();
    private get logDecodeOk();
    decode<T>(loc: string, walker: Walker, decode: Decode<T>): T;
    refineDecodeLoc<T>(loc: string, decode: () => T): T;
    /**
     * Sets itself as current global tracker
     */
    mount(): void;
    /**
     * Unmounts itself from 'current tracker' position. If it is not current, it throws
     */
    unmount(): void;
    private buildDecodeTree;
}

export declare interface LoggerConfig {
    /**
     * @default true
     */
    logDecodeErrors?: boolean;
    /**
     * @default false
     */
    logDecodeSuccesses?: boolean;
}

export declare type MapCodecAndFactory<T extends Map<any, any>, U extends Opaque<T, T>> = Codec<U> & DefineOpaque<T, U>;

export { Opaque }

declare type OpaqueRecursive<T> = Opaque<T, T>;

export declare type RefineDecodeLocFn = <T>(loc: string, headlessDecode: () => T) => T;

export declare type SetCodecAndFactory<T extends Set<any>, U extends Opaque<T, T>> = Codec<U> & DefineOpaque<T, U>;

/**
 * **Caution**: uses global state
 */
export declare function setCurrentTracker(tracker: null | CodecTracker): void;

export declare type Str = string;

export declare const Str: Codec<string, string>;

export declare type StructCodecAndFactory<T, U extends Opaque<T, T>> = Codec<U> & DefineOpaque<T, U>;

export declare type StructCodecsSchema<T> = {
    [K in keyof T]: [K, Codec<T[K]>];
}[keyof T][];

export declare function trackableCodec<E, D = E>(name: string, encode: Encode<E>, decode: Decode<D>): Codec<E, D>;

/**
 * **Caution**: uses global state
 */
export declare const trackDecode: TrackDecodeFn;

export declare type TrackDecodeFn = <T>(loc: string, walker: Walker, decode: Decode<T>) => T;

/**
 * **Caution**: uses global state
 */
export declare const trackRefineDecodeLoc: RefineDecodeLocFn;

/**
 * This symbol could be used by tracker to inspect value
 */
export declare const TrackValueInspect: unique symbol;

/**
 * Implement this for the object if you want to handle its inspection in the console
 */
export declare interface TrackValueInspectable {
    [TrackValueInspect]: () => any;
}

export declare function tryInspectValue(value: any): any;

export declare type TupleCodecs<T extends any[]> = T extends [infer Head, ...infer Tail] ? [Codec<Head>, ...TupleCodecs<Tail>] : [];

export declare type U128 = bigint;

export declare const U128: Codec<bigint, bigint>;

export declare type U16 = number;

export declare const U16: Codec<number, number>;

export declare type U32 = number;

export declare const U32: Codec<number, number>;

export declare type U64 = bigint;

export declare const U64: Codec<bigint, bigint>;

export declare type U8 = number;

export declare const U8: Codec<number, number>;

export declare type VecU8 = Uint8Array;

export declare const VecU8: Codec<Uint8Array, Uint8Array>;

export declare type Void = null;

export declare const Void: Codec<null, null>;


export * from "@scale-codec/core";

export { }
