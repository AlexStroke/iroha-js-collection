// packages/definition-runtime/src/lib.ts
export * from "@scale-codec/core";

// packages/definition-runtime/src/core.ts
import { WalkerImpl, encodeFactory } from "@scale-codec/core";

// packages/definition-runtime/src/tracking/types.ts
var TrackValueInspect = Symbol("TrackValueInspect");

// packages/definition-runtime/src/tracking/current.ts
var __currentTracker = null;
function getCurrentTracker() {
  return __currentTracker;
}
function setCurrentTracker(tracker) {
  __currentTracker = tracker;
}
var trackDecode = (loc, walker, decode) => {
  return __currentTracker?.decode?.(loc, walker, decode) ?? decode(walker);
};
var trackRefineDecodeLoc = (loc, headlessDecode) => {
  return __currentTracker?.refineDecodeLoc?.(loc, headlessDecode) ?? headlessDecode();
};

// packages/definition-runtime/src/tracking/decode-trace.ts
import { assert } from "@scale-codec/util";
import { Fmt, fmt, sub } from "fmt-subs";

// packages/definition-runtime/src/tracking/util.ts
import { toHex } from "@scale-codec/util";
var ELLIPSIS = "\u2026";
function formatU8(u8, start, end) {
  const hex = toHex(u8.subarray(Math.min(start, end ?? Infinity), Math.max(start, end ?? Infinity)));
  return `${start > 0 ? ELLIPSIS : ""}${hex}${typeof end === "number" && end < u8.length ? ELLIPSIS : ""}`;
}
function formatWalkerOffset(start, end) {
  const offsetValue = typeof end === "number" ? `${start}..${end}` : start;
  let deltaSuffix = "";
  if (typeof end === "number") {
    const delta = end - start;
    deltaSuffix = ` (${delta >= 0 ? `+${delta}` : delta})`;
  }
  return `offset: ${offsetValue}${deltaSuffix}`;
}
function formatWalkerStep(params) {
  return `${formatWalkerOffset(params.offsetStart, params.offsetEnd)}; ${formatU8(params.walker.u8, params.offsetStart, params.offsetEnd)}`;
}
function isTrackValueInspectable(value) {
  return typeof value === "object" && TrackValueInspect in value;
}
function tryInspectValue(value) {
  if (isTrackValueInspectable(value)) {
    return value[TrackValueInspect]();
  }
  return value;
}

// packages/definition-runtime/src/tracking/decode-trace.ts
var DecodeTrace = class {
  parent = null;
  loc;
  input;
  result;
  error;
  children = [];
  constructor(loc) {
    this.loc = [loc];
  }
  findRoot() {
    return this.parent ? this.parent.findRoot() : this;
  }
  get isRoot() {
    return !this.parent;
  }
  setParent(trace) {
    this.parent = trace;
    return this;
  }
  refineLoc(loc) {
    this.loc.push(loc);
    return this;
  }
  setInput(offset) {
    this.input = { offset };
    return this;
  }
};
var DecodeTraceCollector = class {
  current = null;
  decodeStart(loc, walker) {
    if (this.current && !this.current.input) {
      this.current.setInput(walker.idx).refineLoc(loc);
    } else {
      const newTrace = new DecodeTrace(loc).setInput(walker.idx);
      if (!this.current) {
        this.current = newTrace;
      } else {
        const child = newTrace.setParent(this.current);
        this.current.children.push(child);
        this.current = child;
      }
    }
  }
  decodeSuccess(walker, decodedValue) {
    assert(this.current, "No current");
    this.current.result = { value: decodedValue, offset: walker.idx };
    if (!this.current.parent) {
      const trace = this.current;
      this.current = null;
      return trace;
    } else {
      this.current = this.current.parent;
      return null;
    }
  }
  decodeError(err) {
    assert(this.current, "No current");
    this.current.error = err;
    return this.current.findRoot();
  }
  refineLoc(loc) {
    assert(this.current, "No current");
    if (this.current.input) {
      const newTrace = new DecodeTrace(loc).setParent(this.current);
      this.current.children.push(newTrace);
      this.current = newTrace;
    } else {
      this.current.refineLoc(loc);
    }
  }
};
function tracePath(trace) {
  const path = [];
  for (let current = trace; current; current = current.parent) {
    for (let len = current.loc.length, i = len - 1; i >= 0; i--) {
      path.push(current.loc[i]);
    }
  }
  path.reverse();
  return path;
}
var INDENT = " ".repeat(4);
function buildStepsRecursive(trace, ctx) {
  const errored = !!trace.error;
  const resultVal = trace.result;
  const path = tracePath(trace).join(" / ");
  const result = errored ? fmt`ERROR - ${sub(trace.error, "%s")}` : resultVal ? sub(tryInspectValue(resultVal.value), "%O") : "<not computed>";
  const walk = trace.input ? `<${formatWalkerStep({
    walker: ctx.walker,
    offsetStart: trace.input.offset,
    offsetEnd: trace.result?.offset
  })}>` : "<no input>";
  let acc = Fmt.concat(fmt`${path}\n`, fmt`${INDENT}Walk: ${walk}\n`, fmt`${INDENT}Result: ${result}\n`, fmt`${INDENT}Child steps: ${trace.children.length}\n`);
  if (trace.children.length) {
    acc = acc.concat(...trace.children.map((x) => buildStepsRecursive(x, ctx)));
  }
  return acc;
}
function buildDecodeTraceStepsFmt(trace, walker) {
  return buildStepsRecursive(trace, { walker });
}

// packages/definition-runtime/src/tracking/logger.ts
import { fmt as fmt2 } from "fmt-subs";
function logError(format, ...args) {
  console.error(`[SCALE] ${format}`, ...args);
}
function logDebug(format, ...args) {
  console.debug(`[SCALE] ${format}`, ...args);
}
var Logger = class {
  config;
  decodeTracer = new DecodeTraceCollector();
  decodeCurrentDepth = 0;
  decodeErrorHandled = false;
  constructor(config) {
    this.config = config;
  }
  get logDecodeErrors() {
    return this.config?.logDecodeErrors ?? true;
  }
  get logDecodeOk() {
    return this.config?.logDecodeSuccesses ?? false;
  }
  decode(loc, walker, decode) {
    try {
      this.decodeCurrentDepth++;
      this.decodeTracer.decodeStart(loc, walker);
      const value = decode(walker);
      const maybeRootTrace = this.decodeTracer.decodeSuccess(walker, value);
      if (maybeRootTrace && this.logDecodeOk) {
        const tree = this.buildDecodeTree(maybeRootTrace, walker);
        logDebug(...fmt2`Decode of "${maybeRootTrace.loc}" succeed\n\nDecode steps:\n\n${tree}`.assemble());
      }
      return value;
    } catch (err) {
      if (!this.decodeErrorHandled) {
        this.decodeErrorHandled = true;
        const trace = this.decodeTracer.decodeError(err);
        if (this.logDecodeErrors) {
          const tree = this.buildDecodeTree(trace, walker);
          logError(...fmt2`Decode of "${trace.loc}" failed with error: ${err}\n\nDecode steps:\n\n${tree}`.assemble());
        }
      }
      throw err;
    } finally {
      if (!--this.decodeCurrentDepth) {
        this.decodeErrorHandled = false;
      }
    }
  }
  refineDecodeLoc(loc, decode) {
    this.decodeTracer.refineLoc(loc);
    return decode();
  }
  mount() {
    const current = getCurrentTracker();
    if (current && current !== this)
      throw new Error("Something is already mounted");
    if (!current) {
      setCurrentTracker(this);
    }
  }
  unmount() {
    const current = getCurrentTracker();
    if (current === this) {
      setCurrentTracker(null);
    }
    throw new Error("This tracker is not mounted");
  }
  buildDecodeTree(trace, walker) {
    return buildDecodeTraceStepsFmt(trace, walker);
  }
};

// packages/definition-runtime/src/core.ts
function trackableCodec(name, encode, decode) {
  const decodeTracked = (walker) => trackDecode(name, walker, decode);
  return {
    encodeRaw: encode,
    decodeRaw: decodeTracked,
    toBuffer: (value) => WalkerImpl.encode(value, encode),
    fromBuffer: (src) => WalkerImpl.decode(src, decodeTracked)
  };
}
function dynCodec(getter) {
  let codec;
  const getCodec = () => {
    if (!codec) {
      codec = getter();
    }
    return codec;
  };
  return {
    encodeRaw: encodeFactory((val, walker) => (codec ?? getCodec()).encodeRaw(val, walker), (val) => (codec ?? getCodec()).encodeRaw.sizeHint(val)),
    decodeRaw: (walker) => (codec ?? getCodec()).decodeRaw(walker),
    toBuffer: (value) => (codec ?? getCodec()).toBuffer(value),
    fromBuffer: (src) => (codec ?? getCodec()).fromBuffer(src)
  };
}

// packages/definition-runtime/src/create.ts
import {
  Enum,
  createArrayDecoder,
  createArrayEncoder,
  createEnumDecoder,
  createEnumEncoder,
  createMapDecoder,
  createMapEncoder,
  createSetDecoder,
  createSetEncoder,
  createStructDecoder,
  createStructEncoder,
  createTupleDecoder,
  createTupleEncoder,
  createUint8ArrayDecoder,
  createUint8ArrayEncoder,
  createVecDecoder,
  createVecEncoder
} from "@scale-codec/core";
var createYetAnotherOpaqueReturn = () => (actual) => actual;
var mergePropsWithFunction = (fn, props) => Object.assign(fn, props);
function createArrayCodec(name, itemCodec, len) {
  const define = createYetAnotherOpaqueReturn();
  const codec = trackableCodec(name, createArrayEncoder(itemCodec.encodeRaw, len), createArrayDecoder(itemCodec.decodeRaw, len));
  return mergePropsWithFunction(define, codec);
}
function createArrayU8Codec(name, len) {
  return trackableCodec(name, createUint8ArrayEncoder(len), createUint8ArrayDecoder(len));
}
function createVecCodec(name, itemCodec) {
  const codec = trackableCodec(name, createVecEncoder(itemCodec.encodeRaw), createVecDecoder(itemCodec.decodeRaw));
  const define = createYetAnotherOpaqueReturn();
  return mergePropsWithFunction(define, codec);
}
function createTupleCodec(name, codecs) {
  const encoders = [];
  const decoders = [];
  for (let i = 0, len = codecs.length, codec2 = codecs[i]; i < len; i++, codec2 = codecs[i]) {
    encoders.push(codec2.encodeRaw);
    decoders.push((walker) => trackRefineDecodeLoc(`<tuple>.${i}`, () => codec2.decodeRaw(walker)));
  }
  const codec = trackableCodec(name, createTupleEncoder(encoders), createTupleDecoder(decoders));
  const define = createYetAnotherOpaqueReturn();
  return mergePropsWithFunction(define, codec);
}
var simpleEnumFactory = (...args) => Enum.variant(...args);
function createEnumCodec(name, schema) {
  const encoders = {};
  const decoders = {};
  for (const [dis, tag, codec2] of schema) {
    ;
    encoders[tag] = codec2 ? [dis, codec2.encodeRaw] : dis;
    decoders[dis] = codec2 ? [tag, (walker) => trackRefineDecodeLoc(`<enum>::${tag}`, () => codec2.decodeRaw(walker))] : tag;
  }
  const codec = trackableCodec(name, createEnumEncoder(encoders), createEnumDecoder(decoders));
  return mergePropsWithFunction(simpleEnumFactory.bind({}), codec);
}
function createOptionCodec(name, someCodec) {
  return createEnumCodec(name, [
    [0, "None"],
    [1, "Some", someCodec]
  ]);
}
function createResultCodec(name, okCodec, errCodec) {
  return createEnumCodec(name, [
    [0, "Ok", okCodec],
    [1, "Err", errCodec]
  ]);
}
function createStructCodec(name, orderedCodecs) {
  const decoders = [];
  const encoders = [];
  for (const [field, codec2] of orderedCodecs) {
    decoders.push([field, (walker) => trackRefineDecodeLoc(`<struct>.${field}`, () => codec2.decodeRaw(walker))]);
    encoders.push([field, codec2.encodeRaw]);
  }
  const codec = trackableCodec(name, createStructEncoder(encoders), createStructDecoder(decoders));
  return mergePropsWithFunction(createYetAnotherOpaqueReturn(), codec);
}
function createMapCodec(name, keyCodec, valueCodec) {
  const codec = trackableCodec(name, createMapEncoder(keyCodec.encodeRaw, valueCodec.encodeRaw), createMapDecoder((walker) => trackRefineDecodeLoc("<map>.<key>", () => keyCodec.decodeRaw(walker)), (walker) => trackRefineDecodeLoc("<map>.<value>", () => valueCodec.decodeRaw(walker))));
  return mergePropsWithFunction(createYetAnotherOpaqueReturn(), codec);
}
function createSetCodec(name, itemCodec) {
  const codec = trackableCodec(name, createSetEncoder(itemCodec.encodeRaw), createSetDecoder(itemCodec.decodeRaw));
  return mergePropsWithFunction(createYetAnotherOpaqueReturn(), codec);
}

// packages/definition-runtime/src/codecs.ts
import {
  decodeBool,
  decodeCompact,
  decodeI128,
  decodeI16,
  decodeI32,
  decodeI64,
  decodeI8,
  decodeStr,
  decodeU128,
  decodeU16,
  decodeU32,
  decodeU64,
  decodeU8,
  decodeUint8Vec,
  decodeVoid,
  encodeBool,
  encodeCompact,
  encodeI128,
  encodeI16,
  encodeI32,
  encodeI64,
  encodeI8,
  encodeStr,
  encodeU128,
  encodeU16,
  encodeU32,
  encodeU64,
  encodeU8,
  encodeUint8Vec,
  encodeVoid
} from "@scale-codec/core";
var U8 = trackableCodec("u8", encodeU8, decodeU8);
var I8 = trackableCodec("i8", encodeI8, decodeI8);
var U16 = trackableCodec("u16", encodeU16, decodeU16);
var I16 = trackableCodec("i16", encodeI16, decodeI16);
var U32 = trackableCodec("u32", encodeU32, decodeU32);
var I32 = trackableCodec("i32", encodeI32, decodeI32);
var U64 = trackableCodec("u64", encodeU64, decodeU64);
var I64 = trackableCodec("i64", encodeI64, decodeI64);
var U128 = trackableCodec("u128", encodeU128, decodeU128);
var I128 = trackableCodec("i128", encodeI128, decodeI128);
var Str = trackableCodec("str", encodeStr, decodeStr);
var Bool = trackableCodec("bool", encodeBool, decodeBool);
var Void = trackableCodec("void", encodeVoid, decodeVoid);
var VecU8 = trackableCodec("VecU8", encodeUint8Vec, decodeUint8Vec);
var Compact = trackableCodec("compact", encodeCompact, decodeCompact);
export {
  Bool,
  Compact,
  DecodeTrace,
  DecodeTraceCollector,
  I128,
  I16,
  I32,
  I64,
  I8,
  Logger,
  Str,
  TrackValueInspect,
  U128,
  U16,
  U32,
  U64,
  U8,
  VecU8,
  Void,
  buildDecodeTraceStepsFmt,
  createArrayCodec,
  createArrayU8Codec,
  createEnumCodec,
  createMapCodec,
  createOptionCodec,
  createResultCodec,
  createSetCodec,
  createStructCodec,
  createTupleCodec,
  createVecCodec,
  dynCodec,
  formatWalkerStep,
  getCurrentTracker,
  isTrackValueInspectable,
  setCurrentTracker,
  trackDecode,
  trackRefineDecodeLoc,
  trackableCodec,
  tryInspectValue
};
